```dataviewjs
// Generated by planner_refactor/tools/bundle.py
(() => {
const __modules = {};
function __define(id, factory){
  __modules[id] = { factory, exports: {}, initialized: false };
}
function __resolve(from, target){
  if (target.startsWith('.')){
    const fromParts = from.split('/');
    fromParts.pop();
    const targetParts = target.split('/');
    for (const part of targetParts){
      if (part === '.' || part === '') continue;
      if (part === '..') fromParts.pop();
      else fromParts.push(part);
    }
    return fromParts.join('/');
  }
  return target;
}
function __requireModule(id){
  const mod = __modules[id];
  if (!mod) throw new Error('Module not found: ' + id);
  if (!mod.initialized){
    mod.initialized = true;
    mod.factory(mod, mod.exports, createLocalRequire(id));
  }
  return mod.exports;
}
function createLocalRequire(fromId){
  return function(target){
    const resolved = __resolve(fromId, target);
    const withExt = resolved.endsWith('.js') ? resolved : resolved + '.js';
    return __requireModule(withExt);
  };
}

__define('env/dateParts.js', function(module, exports, require) {
/**
 * Derive human friendly date components for front-matter.
 * @param {string} dateStr - YYYY-MM-DD.
 * @returns {Object} Parts object.
 */
function getDateParts(dateStr) {
  try {
    const [y, m, d] = String(dateStr).split("-").map(Number);
    const dt = new Date(y, (m || 1) - 1, d || 1);
    return {
      day_week: dt.toLocaleDateString("en-US", { weekday: "long" }),
      day: d,
      month: dt.toLocaleDateString("en-US", { month: "long" }),
      year: y,
    };
  } catch (e) {
    return { day_week: "", day: "", month: "", year: "" };
  }
}

module.exports = { getDateParts };

});
__define('env/device.js', function(module, exports, require) {
const { createNowHelpers } = require("../time/now");

/**
 * Detect whether the planner should run in mobile mode.
 * @param {Object} deps - Environment deps.
 * @param {App} deps.app - Obsidian app instance.
 * @param {boolean} deps.forceMobile - Override for testing.
 * @returns {Object} Mobile flags and suffix.
 */
function createDeviceEnv({ app, forceMobile = false }) {
  const { nowDate } = createNowHelpers();

  const detectMobile = () => {
    if (forceMobile) return true;
    try {
      if (typeof app !== "undefined" && app.isMobile) return true;
      if (window.matchMedia("(max-width: 768px)").matches) return true;
    } catch (e) {
      /* ignore */
    }
    return false;
  };

  const isMobile = detectMobile();

  return {
    isMobile,
    suffix: isMobile ? "_m" : "",
    currentDate: nowDate(),
  };
}

module.exports = { createDeviceEnv };

});
__define('env/paths.js', function(module, exports, require) {
/**
 * Resolve vault-relative paths used by the planner.
 * @param {Object} options - Planner environment options.
 * @param {string} options.suffix - Mobile/desktop suffix.
 * @returns {Object} Path helpers.
 */
function createPathEnv({ suffix }) {
  const MAIN_LOG_FOLDER = "0-Vault/02-Areas/04-Thoughts_and_Observations/";
  const LOG_PROJECT_NAME = "2026";
  const FULL_LOG_FOLDER = MAIN_LOG_FOLDER + LOG_PROJECT_NAME;

  const AGENDA_BASE_PATH = "0-Vault/02-Areas/02-Agenda/2026/";
  const CONSUMPTION_BASE_PATH = "0-Vault/02-Areas/06-Body-Mind/Health/Piled_up/";

  const ACTIVITY_LIST_PATH =
    "0-Vault/02-Areas/11-Gardening/Planning/RelevantInformation/Activity_List.md";
  const CONSUMPTION_LIST_PATH =
    "0-Vault/02-Areas/11-Gardening/Planning/RelevantInformation/Consumption_List.md";
  const RELATED_FILES_PATH =
    "0-Vault/02-Areas/11-Gardening/Planning/RelevantInformation/related_files.md";

  const getThoughtsFile = (d) => `${FULL_LOG_FOLDER}/${d}-Thoughts_and_Observations${suffix}.md`;
  const getMetaLogFile = (d) => `${FULL_LOG_FOLDER}/meta_log/${d}${suffix}.md`;
  const getPrimaryAgendaFile = (d) => `${AGENDA_BASE_PATH}${d}-Agenda${suffix}.md`;
  const getConsumptionLogFile = (d) => {
    const [yy, mm] = String(d).split("-");
    return `${CONSUMPTION_BASE_PATH}${yy}_${mm}${suffix}.md`;
  };
  const getEdLogFile = (d) => `${AGENDA_BASE_PATH}EdLog/${d}_EdLog${suffix}.md`;

  return {
    MAIN_LOG_FOLDER,
    LOG_PROJECT_NAME,
    FULL_LOG_FOLDER,
    AGENDA_BASE_PATH,
    CONSUMPTION_BASE_PATH,
    ACTIVITY_LIST_PATH,
    CONSUMPTION_LIST_PATH,
    RELATED_FILES_PATH,
    getThoughtsFile,
    getMetaLogFile,
    getPrimaryAgendaFile,
    getConsumptionLogFile,
    getEdLogFile,
  };
}

module.exports = { createPathEnv };

});
__define('index.js', function(module, exports, require) {
/**
 * DataviewJS entrypoint that wires together the modular planner.
 * This file should be bundled into a single DataviewJS block via tools/bundle.py.
 */
const { createPlannerState } = require("./state/PlannerState");
const { updatePlannerDate } = require("./state/updateDate");
const { ensurePrimaryAgendaFile, ensureLogFilesForDate } = require("./mutate/ensureFiles");
const { logThought } = require("./mutate/logThought");
const { handleBreak } = require("./mutate/handleBreak");
const { refreshThoughtLog } = require("./ui/logPanel");
const { baseCss } = require("./ui/ui_shared/baseStyles");
const { refreshEmbed } = require("./ui/calendar/refreshEmbed");
const { checkNotifications } = require("./notify/checkNotifications");
const { createSuggester } = require("./ui/suggester/suggester");

(function initPlanner() {
  const CONFIG = { FORCE_MOBILE_MODE: false };
  const state = createPlannerState({ app, dv, config: CONFIG });

  const wrap = this.container.createEl("div", { cls: "chat-wrap" });
  const component = this.component;
  wrap.createEl("style", { text: baseCss });

  const sourceRow = wrap.createEl("div", { cls: "row" });
  const sourceBox = sourceRow.createEl("textarea", { cls: "ref", text: state.device.isMobile ? "edwin-mobile" : "edwin" });
  const task = sourceRow.createEl("textarea", { cls: "ref2", text: "" });
  task.tabIndex = -1;
  sourceBox.tabIndex = -1;

  const textBox = wrap.createEl("textarea", { placeholder: "Type " });
  const actions = wrap.createEl("div", { cls: "row" });

  const toDo = actions.createEl("button", { cls: "btn", text: "toDo" });
  const editBtn = actions.createEl("button", { cls: "btn", text: "<" });
  const consumeBtn = actions.createEl("button", { cls: "btn", text: "Consume" });
  const breakBtn = actions.createEl("button", { cls: "btn", text: "Break" });
  const sendBtn = actions.createEl("button", { cls: "btn", text: "Send ⏎" });
  const modeLabel = state.device.isMobile ? "(M)" : "";
  const dateBtn = actions.createEl("button", { cls: "btn", text: `${state.currentPlannerDate} ${modeLabel}` });
  const embedBtn = actions.createEl("button", { cls: "btn", text: "Agenda" });

  const logBox = wrap.createEl("div", { cls: "log" });
  const embedBox = wrap.createEl("div", { cls: "embed-box" });

  const calendarBox = document.createElement("div");
  calendarBox.className = "cal-box";
  calendarBox.style.display = "none";
  document.body.appendChild(calendarBox);
  component.register(() => {
    try {
      calendarBox.remove();
    } catch (e) {
      /* ignore */
    }
  });

  let calViewYear = Number(String(state.currentPlannerDate).split("-")[0] || new Date().getFullYear());
  let calViewMonth = Number(String(state.currentPlannerDate).split("-")[1] || new Date().getMonth() + 1) - 1;

  async function sendThought() {
    const content = textBox.value.trim();
    if (!content) return;
    await logThought(state, { content, source: sourceBox.value.trim() });
    sourceBox.value = state.device.isMobile ? "edwin-mobile" : "edwin";
    textBox.value = "";
    await refreshThoughtLog(state, logBox);
    textBox.focus();
  }

  const suggester = createSuggester(
    state,
    { textBox, taskBox: task, panelHost: document.body, onSend: sendThought },
    () => refreshEmbed(state, embedBox)
  );
  component.register(() => suggester.destroy());

  function fmtDate(y, m, d) {
    return `${y}-${String(m + 1).padStart(2, "0")}-${String(d).padStart(2, "0")}`;
  }

  function renderCalendar() {
    const first = new Date(calViewYear, calViewMonth, 1);
    const startDow = (first.getDay() + 6) % 7;
    const daysInMonth = new Date(calViewYear, calViewMonth + 1, 0).getDate();
    const prevDays = new Date(calViewYear, calViewMonth, 0).getDate();
    const todayStr = state.now.nowDate();
    calendarBox.innerHTML = "";
    const head = document.createElement("div");
    head.className = "cal-head";
    const navL = document.createElement("div");
    navL.className = "cal-nav";
    const byPrevYear = document.createElement("button");
    byPrevYear.textContent = "«";
    const byPrevMonth = document.createElement("button");
    byPrevMonth.textContent = "‹";
    const byNextMonth = document.createElement("button");
    byNextMonth.textContent = "›";
    const byNextYear = document.createElement("button");
    byNextYear.textContent = "»";
    byPrevYear.onclick = () => {
      calViewYear -= 1;
      renderCalendar();
    };
    byNextYear.onclick = () => {
      calViewYear += 1;
      renderCalendar();
    };
    byPrevMonth.onclick = () => {
      calViewMonth -= 1;
      if (calViewMonth < 0) {
        calViewMonth = 11;
        calViewYear -= 1;
      }
      renderCalendar();
    };
    byNextMonth.onclick = () => {
      calViewMonth += 1;
      if (calViewMonth > 11) {
        calViewMonth = 0;
        calViewYear += 1;
      }
      renderCalendar();
    };
    navL.append(byPrevYear, byPrevMonth);
    const title = document.createElement("div");
    title.className = "cal-title";
    title.textContent = `${monthName(calViewMonth)} ${calViewYear}`;
    const navR = document.createElement("div");
    navR.className = "cal-nav";
    navR.append(byNextMonth, byNextYear);
    head.append(navL, title, navR);
    const grid = document.createElement("div");
    grid.className = "cal-grid";
    for (let i = 0; i < 42; i += 1) {
      const cell = document.createElement("div");
      cell.className = "cal-day";
      let y = calViewYear;
      let m = calViewMonth;
      let d = 0;
      if (i < startDow) {
        d = prevDays - (startDow - 1 - i);
        cell.classList.add("muted");
        m = calViewMonth - 1;
        y = calViewYear;
        if (m < 0) {
          m = 11;
          y -= 1;
        }
      } else if (i >= startDow + daysInMonth) {
        d = i - (startDow + daysInMonth) + 1;
        cell.classList.add("muted");
        m = calViewMonth + 1;
        y = calViewYear;
        if (m > 11) {
          m = 0;
          y += 1;
        }
      } else {
        d = i - startDow + 1;
      }
      const ds = fmtDate(y, m, d);
      cell.textContent = String(d);
      if (ds === todayStr) cell.classList.add("today");
      if (ds === state.currentPlannerDate) cell.classList.add("selected");
      cell.onclick = () => {
        setPlannerDate(ds);
        calendarBox.style.display = "none";
      };
      grid.appendChild(cell);
    }
    const week = document.createElement("div");
    week.className = "cal-week";
    ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"].forEach((w) => {
      const d = document.createElement("div");
      d.textContent = w;
      week.appendChild(d);
    });
    calendarBox.append(head, week, grid);
  }

  function positionCalendar() {
    const r = dateBtn.getBoundingClientRect();
    const w = 320;
    const left = Math.min(Math.max(8, r.left), window.innerWidth - w - 8);
    const top = Math.min(r.bottom + 6, window.innerHeight - 380);
    calendarBox.style.left = `${left}px`;
    calendarBox.style.top = `${top}px`;
  }

  function openCalendar() {
    renderCalendar();
  }

  function monthName(m) {
    try {
      return new Date(2000, m, 1).toLocaleDateString("en-US", { month: "long" });
    } catch (e) {
      return String(m + 1);
    }
  }

  async function setPlannerDate(dStr) {
    updatePlannerDate(state, dStr);
    dateBtn.textContent = `${state.currentPlannerDate} ${modeLabel}`;
    await ensureLogFilesForDate(state, state.currentPlannerDate);
    await ensurePrimaryAgendaFile(state);
    if (embedBox.style.display !== "none") refreshEmbed(state, embedBox);
    await refreshThoughtLog(state, logBox);
  }

  async function runNotificationCheck() {
    const result = await checkNotifications(state);
    if (result.alert) {
      task.textContent = result.alert;
      task.style.color = "#ff4444";
    } else {
      task.textContent = "";
      task.style.color = "";
    }
  }

  dateBtn.onclick = (e) => {
    e.stopPropagation();
    if (calendarBox.style.display === "none") {
      openCalendar();
      positionCalendar();
      calendarBox.style.display = "block";
    } else calendarBox.style.display = "none";
  };

  sendBtn.addEventListener("click", () => {
    sendBtn.textContent = "...";
    sendThought();
    setTimeout(() => (sendBtn.textContent = "Send ⏎"), 500);
  });

  toDo.addEventListener("click", () => {
    sourceBox.value = sourceBox.value === "toDo" ? "edwin" : "toDo";
  });

  editBtn.addEventListener("click", async () => {
    editBtn.textContent = "...";
    await ensurePrimaryAgendaFile(state);
    suggester.openAgendaRoot();
    textBox.focus();
    setTimeout(() => (editBtn.textContent = "<"), 500);
  });

  consumeBtn.addEventListener("click", () => {
    consumeBtn.textContent = "...";
    suggester.openConsumption();
    textBox.focus();
    setTimeout(() => (consumeBtn.textContent = "Consume"), 500);
  });

  breakBtn.addEventListener("click", async () => {
    breakBtn.textContent = "...";
    const outcome = await handleBreak(state, () => refreshEmbed(state, embedBox));
    if (outcome.resumeCandidates && outcome.resumeCandidates.length > 0) {
      state.uiState.pending.resumable = outcome.resumeCandidates;
      state.uiState.suggestMode = "agenda-resume";
      suggester.reposition();
      suggester.rerender();
      suggester.panel.style.display = "block";
      state.uiState.panelOpen = true;
    } else {
      task.textContent = outcome.started ? "Started Break." : "Break ended.";
    }
    setTimeout(() => (breakBtn.textContent = "Break"), 500);
  });

  embedBtn.onclick = async () => {
    if (embedBox.style.display === "none") {
      await ensurePrimaryAgendaFile(state);
      await refreshEmbed(state, embedBox);
      embedBox.style.display = "block";
      embedBtn.textContent = "Hide Agenda";
    } else {
      embedBox.style.display = "none";
      embedBtn.textContent = "Agenda";
    }
  };

  textBox.addEventListener("input", () => suggester.handleInput());
  textBox.addEventListener("keydown", (e) => suggester.handleKeydown(e));

  (async () => {
    await ensurePrimaryAgendaFile(state);
    await refreshThoughtLog(state, logBox);
    await runNotificationCheck();
  })();

  const intervalId = setInterval(() => runNotificationCheck(), 30000);
  component.register(() => clearInterval(intervalId));
})(); 

});
__define('io/files.js', function(module, exports, require) {
/**
 * Centralized vault I/O helpers. All file reads and writes flow through here.
 * @param {Object} deps - Dependencies.
 * @param {App} deps.app - Obsidian app instance.
 * @returns {Object} Helper methods for file operations.
 */
function createIo({ app }) {
  const adapter = app?.vault?.adapter;

  const resolveVaultPath = async (targetPath) => {
    try {
      const normalized = String(targetPath || "").replace(/\\/g, "/");
      const lc = normalized.toLowerCase();
      const files = app.vault.getFiles();
      const hit = files.find((f) => f.path.replace(/\\/g, "/").toLowerCase() === lc);
      if (hit) return hit.path;
    } catch (e) {
      /* ignore */
    }
    return targetPath;
  };

  const ensureFolder = async (folder) => {
    if (!adapter) return;
    if (!(await adapter.exists(folder))) {
      try {
        await adapter.mkdir(folder);
      } catch (e) {
        /* ignore */
      }
    }
  };

  const ensureFile = async (path, template = "") => {
    if (!adapter) return;
    const folder = path.substring(0, path.lastIndexOf("/"));
    if (folder) await ensureFolder(folder);
    if (!(await adapter.exists(path))) {
      await app.vault.create(path, template);
    }
  };

  const append = async (path, text) => {
    if (!adapter) return;
    const folder = path.substring(0, path.lastIndexOf("/"));
    if (folder) await ensureFolder(folder);
    await adapter.append(path, text);
  };

  const read = async (path) => {
    if (!adapter) return "";
    return adapter.read(path);
  };

  const write = async (path, content) => {
    if (!adapter) return;
    await adapter.write(path, content);
  };

  const exists = async (path) => {
    if (!adapter) return false;
    return adapter.exists(path);
  };

  return { resolveVaultPath, ensureFolder, ensureFile, append, read, write, exists };
}

module.exports = { createIo };

});
__define('model/Activity.js', function(module, exports, require) {
/**
 * Activity domain object captured from agenda tables.
 * @param {Object} params - Activity attributes.
 * @param {string|number} params.id - Unique agenda row identifier.
 * @param {string} params.name - Activity label.
 * @param {string} params.start - Start cell value (may include tags).
 * @param {string} params.end - End cell value (may include tags).
 * @param {string} params.sourceFile - Originating file path.
 * @param {string} [params.sourceType] - Source label (Desktop/Mobile/Log).
 * @returns {Object} Activity.
 */
function Activity({ id, name, start, end, sourceFile, sourceType = "Desktop" }) {
  return { id: String(id), name, start, end, sourceFile, sourceType };
}

module.exports = { Activity };

});
__define('model/ConsumptionItem.js', function(module, exports, require) {
/**
 * Consumption entry captured in monthly log files.
 * @param {Object} params - Attributes.
 * @param {number|string} params.id - Row id.
 * @param {string} params.date - Date string.
 * @param {string} params.item - Item name.
 * @param {string} params.time - Time string.
 * @param {string} params.amount - Amount string.
 * @returns {Object} Consumption item model.
 */
function ConsumptionItem({ id, date, item, time, amount }) {
  return { id, date, item, time, amount };
}

module.exports = { ConsumptionItem };

});
__define('model/EditEvent.js', function(module, exports, require) {
/**
 * EditEvent represents a change recorded in the EdLog.
 * @param {Object} params - Event attributes.
 * @param {number} params.logId - Incremental log identifier.
 * @param {string|number} params.activityId - Activity id.
 * @param {string} params.date - Date string (YYYY-MM-DD).
 * @param {string} params.time - Time string (HH:mm).
 * @param {string} params.activity - Activity name.
 * @param {string} params.start - Start value.
 * @param {string} params.end - End value.
 * @returns {Object} EditEvent.
 */
function EditEvent({ logId, activityId, date, time, activity, start, end }) {
  return { logId, activityId: String(activityId), date, time, activity, start, end };
}

module.exports = { EditEvent };

});
__define('mutate/deleteActivity.js', function(module, exports, require) {
const { logActivityChange } = require("./logActivityChange");

/**
 * Non-destructive delete of an activity.
 * @param {Object} state - PlannerState.
 * @param {Object} payload - Delete details.
 * @param {string|number} payload.rowId - Activity id.
 * @param {string} payload.activityName - Name for logging.
 * @param {string|null} [payload.targetFile] - Source file.
 * @param {boolean} [payload.skipRefresh] - Skip refresh callback.
 * @param {Function} [payload.onRefresh] - Optional refresh handler.
 */
async function deleteActivity(state, payload) {
  const { rowId, activityName, targetFile = null, skipRefresh = false, onRefresh } = payload;
  const sourceFile = targetFile || state.primaryAgendaFile;
  try {
    if (sourceFile === state.primaryAgendaFile) {
      const content = await state.io.read(sourceFile);
      const lines = String(content).split("\n");
      const newLines = lines.filter((l) => !l.match(new RegExp(`^\\|\\s*${rowId}\\s*\\|`)));
      if (lines.length !== newLines.length) {
        await state.io.write(sourceFile, newLines.join("\n"));
        await logActivityChange(state, { actId: rowId, name: activityName, startVal: "DELETED", endVal: "DELETED" });
      }
    } else {
      const tombstone = `| ${rowId} | ${activityName.padEnd(28)} | DELETED | DELETED |`;
      await state.io.append(state.primaryAgendaFile, `${tombstone}\n`);
      await logActivityChange(state, { actId: rowId, name: activityName, startVal: "DELETED", endVal: "DELETED" });
    }
    if (!skipRefresh && typeof onRefresh === "function") setTimeout(() => onRefresh(), 50);
  } catch (e) {
    console.error("Delete Error", e);
  }
}

module.exports = { deleteActivity };

});
__define('mutate/editActivity.js', function(module, exports, require) {
const { buildUnifiedActivityMap } = require("../store/unifiedActivityMap");
const { logActivityChange } = require("./logActivityChange");

/**
 * Edit an activity row (name, start, or end).
 * @param {Object} state - PlannerState.
 * @param {Object} payload - Edit details.
 * @param {string|number} payload.rowId - Activity id.
 * @param {"name"|"start"|"end"} payload.field - Field to edit.
 * @param {string} payload.newVal - New value.
 * @param {number|null} [payload.preciseUnix] - Optional unix tag.
 * @param {string|null} [payload.targetFile] - Optional source override.
 * @param {boolean} [payload.skipRefresh] - Skip refresh callback.
 * @param {Function} [payload.onRefresh] - Optional refresh function.
 */
async function editActivity(state, payload) {
  const { rowId, field, newVal, preciseUnix = null, targetFile = null, skipRefresh = false, onRefresh } = payload;
  try {
    const unifiedMap = await buildUnifiedActivityMap(state);
    const activity = unifiedMap.get(String(rowId));
    if (!activity) return;

    let pName = activity.name.trim();
    let pStart = activity.start.trim();
    let pEnd = activity.end.trim();

    if (field === "name") pName = newVal;
    else if (field === "start") {
      let newTimeStr = newVal;
      const tMatch = pStart.match(/<t(\\d{1,2}-\\d{2})>/);
      if (tMatch) newTimeStr = `${newVal} <t${tMatch[1]}>`;
      const ts = preciseUnix || state.time.getUnixFromString(newVal);
      newTimeStr += ` <u${ts}>`;
      pStart = newTimeStr;
    } else {
      let newTimeStr = newVal;
      const tMatch = pEnd.match(/<t(\\d{1,2}-\\d{2})>/);
      if (tMatch) newTimeStr = `${newVal} <t${tMatch[1]}>`;
      const ts = preciseUnix || state.time.getUnixFromString(newVal);
      newTimeStr += ` <u${ts}>`;
      pEnd = newTimeStr;
    }

    const sourceFile = targetFile || activity.sourceFile;
    if (sourceFile === state.primaryAgendaFile) {
      const content = await state.io.read(state.primaryAgendaFile);
      const lines = String(content).split("\n");
      const rowIndex = lines.findIndex((l) => l.match(new RegExp(`^\\|\\s*${rowId}\\s*\\|`)));
      if (rowIndex !== -1) {
        const parts = lines[rowIndex].split("|");
        parts[2] = ` ${pName.padEnd(28)} `;
        parts[3] = ` ${pStart.padEnd(10)} `;
        parts[4] = ` ${pEnd} `;
        lines[rowIndex] = parts.join("|");
        await state.io.write(state.primaryAgendaFile, lines.join("\n"));
      }
    } else {
      const newRow = `| ${rowId} | ${pName.padEnd(28)} | ${pStart.padEnd(10)} | ${pEnd} |`;
      await state.io.append(state.primaryAgendaFile, `${newRow}\n`);
    }

    await logActivityChange(state, { actId: rowId, name: pName, startVal: pStart, endVal: pEnd });
    if (!skipRefresh && typeof onRefresh === "function") setTimeout(() => onRefresh(), 50);
  } catch (e) {
    console.error("Edit Error", e);
  }
}

module.exports = { editActivity };

});
__define('mutate/endActivity.js', function(module, exports, require) {
const { buildUnifiedActivityMap } = require("../store/unifiedActivityMap");
const { logActivityChange } = require("./logActivityChange");

/**
 * End an active activity and write result to agenda.
 * @param {Object} state - PlannerState.
 * @param {Object} payload - End parameters.
 * @param {string} payload.activityName - Target activity.
 * @param {string} payload.endTime - HH:mm string.
 * @param {number|null} [payload.preciseUnix] - Optional unix tag.
 * @param {string|null} [payload.targetFile] - Optional target file override.
 * @param {boolean} [payload.skipRefresh] - Skip refresh callback.
 * @param {Function} [payload.onRefresh] - Callback after write.
 * @returns {Promise<number|null>} Start unix tag (for resume prompt).
 */
async function endActivity(state, payload) {
  const { activityName, endTime, preciseUnix = null, targetFile = null, skipRefresh = false, onRefresh } = payload;
  try {
    const unifiedMap = await buildUnifiedActivityMap(state);
    let activity = null;
    for (const act of unifiedMap.values()) {
      if (act.name === activityName) activity = act;
    }
    if (!activity) return null;

    const ts = preciseUnix || state.time.getUnixFromString(endTime);
    const unixTag = ` <u${ts}>`;
    const actStart = activity.start;
    const startUnixMatch = actStart.match(/<u(\\d+)>/);
    const startUnix = startUnixMatch ? startUnixMatch[1] : null;
    const targetAgenda = targetFile || activity.sourceFile;

    if (targetAgenda === state.primaryAgendaFile) {
      const content = await state.io.read(state.primaryAgendaFile);
      const lines = String(content).split("\n");
      const rowIndex = lines.findIndex((l) => l.match(new RegExp(`^\\|\\s*${activity.id}\\s*\\|`)));
      if (rowIndex !== -1) {
        const parts = lines[rowIndex].split("|");
        const oldEnd = parts[4].trim();
        let newEndCell = endTime;
        if (/^\\d{1,2}:\\d{2}/.test(oldEnd) && !oldEnd.startsWith("<")) {
          const pureTime = oldEnd.replace(/<.*?>/g, "").trim();
          if (pureTime !== endTime) {
            const targetTag = pureTime.replace(":", "-");
            newEndCell = `${endTime} <t${targetTag}>`;
          }
        }
        newEndCell += unixTag;
        parts[4] = ` ${newEndCell} `;
        lines[rowIndex] = parts.join("|");
        await state.io.write(state.primaryAgendaFile, lines.join("\n"));
        await logActivityChange(state, { actId: activity.id, name: activityName, startVal: actStart, endVal: newEndCell });
      }
    } else {
      const newEndCell = `${endTime} ${unixTag}`;
      const newRow = `| ${activity.id} | ${activity.name.padEnd(28)} | ${activity.start.padEnd(10)} | ${newEndCell} |`;
      await state.io.append(state.primaryAgendaFile, `${newRow}\n`);
      await logActivityChange(state, { actId: activity.id, name: activityName, startVal: actStart, endVal: newEndCell });
    }

    if (!skipRefresh && typeof onRefresh === "function") setTimeout(() => onRefresh(), 50);
    return startUnix;
  } catch (e) {
    console.error("End Error", e);
    return null;
  }
}

module.exports = { endActivity };

});
__define('mutate/ensureFiles.js', function(module, exports, require) {
const { getDateParts } = require("../env/dateParts");

/**
 * Ensure daily log files exist with expected templates.
 * @param {Object} state - PlannerState.
 * @param {string} dateStr - Target date.
 */
async function ensureLogFilesForDate(state, dateStr) {
  const parts = getDateParts(dateStr);
  const thoughtsFile = state.paths.getThoughtsFile(dateStr);
  const metaLogFile = state.paths.getMetaLogFile(dateStr);

  await state.io.ensureFolder(state.paths.FULL_LOG_FOLDER);
  await state.io.ensureFolder(`${state.paths.FULL_LOG_FOLDER}/meta_log`);

  const thoughtsTemplate = `---
date: ${dateStr}
day_week: ${parts.day_week} 
day: ${parts.day}
month: ${parts.month}
year: ${parts.year}
nurtured: 0
---
[[Thoughts_and_ObservationsList]]\n
| id  | Comment                         | Time  |
| --- | ------------------------------- | ----- |
`;
  await state.io.ensureFile(thoughtsFile, thoughtsTemplate);
  const metaTemplate = `|id|Source|Duration (ms)|
|---|---|---|
`;
  await state.io.ensureFile(metaLogFile, metaTemplate);
}

/**
 * Ensure the primary agenda file exists for the state's current date.
 * @param {Object} state - PlannerState.
 */
async function ensurePrimaryAgendaFile(state) {
  await state.io.ensureFolder(state.paths.AGENDA_BASE_PATH);
  const exists = await state.io.exists(state.primaryAgendaFile);
  if (exists) return;
  const p = getDateParts(state.currentPlannerDate);
  const template = `---
date: ${state.currentPlannerDate}
day_week: ${p.day_week}
day: ${p.day}
month: ${p.month}
year: ${p.year}
nurtured: 0
device: ${state.device.isMobile ? "Mobile" : "Desktop"}
---

[[Agenda]]

| id  | **Activity** | **Start** | **End** |
| --- | ---------------------------- | ---------- | -------- |
`;
  await state.io.ensureFile(state.primaryAgendaFile, template);
}

module.exports = { ensureLogFilesForDate, ensurePrimaryAgendaFile };

});
__define('mutate/getNextTableId.js', function(module, exports, require) {
/**
 * Generate next table id using desktop/mobile split ranges.
 * @param {Object} state - PlannerState.
 * @param {string} filePath - Agenda file path.
 * @returns {Promise<number>} Next id.
 */
async function getNextTableId(state, filePath) {
  try {
    const txt = await state.io.read(filePath);
    const lines = String(txt).split("\n");
    let maxDesktop = 0;
    let maxMobile = 100;
    lines.forEach((line) => {
      const m = line.match(/^\\|\\s*(\\d+)\\s*\\|/);
      if (m) {
        const id = Number(m[1]);
        if (id < 100) maxDesktop = Math.max(maxDesktop, id);
        else maxMobile = Math.max(maxMobile, id);
      }
    });
    return state.device.isMobile ? maxMobile + 1 : maxDesktop + 1;
  } catch (e) {
    return state.device.isMobile ? 101 : 1;
  }
}

module.exports = { getNextTableId };

});
__define('mutate/handleBreak.js', function(module, exports, require) {
const { createActivityQueries } = require("../store/activityQueries");
const { endActivity } = require("./endActivity");
const { startActivity } = require("./startActivity");

/**
 * Toggle break status. Returns resume candidates when ending a break.
 * @param {Object} state - PlannerState.
 * @param {Function} [onRefresh] - Optional refresh callback.
 * @returns {Promise<Object>} Outcome with resumeCandidates.
 */
async function handleBreak(state, onRefresh) {
  const queries = createActivityQueries(state);
  const active = await queries.getActiveActivities();
  const isOnBreak = active.some((a) => a.name === "Break");
  const nowStr = state.now.nowTime();
  const ts = Date.now();

  if (isOnBreak) {
    const activeBreaks = active.filter((a) => a.name === "Break");
    let resumeCandidates = [];
    for (let i = 0; i < activeBreaks.length; i += 1) {
      const brk = activeBreaks[i];
      const isLast = i === activeBreaks.length - 1;
      const breakStartUnix = await endActivity(state, { activityName: "Break", endTime: nowStr, preciseUnix: ts, targetFile: brk.sourceFile, skipRefresh: !isLast, onRefresh });
      if (breakStartUnix) {
        const candidates = await queries.getInterruptedActivitiesByUnix(breakStartUnix, ["Break"]);
        resumeCandidates = resumeCandidates.concat(candidates);
      }
    }
    return { ended: true, resumeCandidates };
  }

  if (active.length > 0) {
    for (let i = 0; i < active.length; i += 1) {
      await endActivity(state, { activityName: active[i].name, endTime: nowStr, preciseUnix: ts, targetFile: active[i].sourceFile, skipRefresh: true });
    }
  }
  await startActivity(state, { activityName: "Break", startTime: nowStr, plannedEndTime: null, existingRowId: null, preciseUnix: ts, skipRefresh: false, onRefresh });
  return { started: true, resumeCandidates: [] };
}

module.exports = { handleBreak };

});
__define('mutate/logActivityChange.js', function(module, exports, require) {
/**
 * Append an activity change entry to the EdLog file.
 * @param {Object} state - PlannerState.
 * @param {Object} payload - Change details.
 * @param {string|number} payload.actId - Activity id.
 * @param {string} payload.name - Activity name.
 * @param {string} payload.startVal - Start column value.
 * @param {string} payload.endVal - End column value.
 */
async function logActivityChange(state, { actId, name, startVal, endVal }) {
  const date = state.currentPlannerDate;
  const logFile = state.paths.getEdLogFile(date);
  try {
    const logFolder = `${state.paths.AGENDA_BASE_PATH}EdLog`;
    await state.io.ensureFolder(logFolder);
    const header = `| LogID | ActID | Date | Time | Activity | Start | End |
|---|---|---|---|---|---|---|
`;
    await state.io.ensureFile(logFile, header);

    const txt = await state.io.read(logFile);
    let maxId = 0;
    String(txt)
      .split("\n")
      .forEach((line) => {
        const m = line.match(/^\\|\\s*(\\d+)\\s*\\|/);
        if (m) maxId = Math.max(maxId, Number(m[1]));
      });
    const logId = maxId + 1;
    const cleanName = String(name).trim().replace(/\\|/g, "");
    const cleanStart = String(startVal).replace(/<.*?>/g, "").trim();
    const cleanEnd = String(endVal).replace(/<.*?>/g, "").trim();
    const row = `| ${logId} | ${actId} | ${state.now.nowDate()} | ${state.now.nowTime()} | ${cleanName} | ${cleanStart} | ${cleanEnd} |
`;
    await state.io.append(logFile, row);
  } catch (e) {
    console.error("EdLog append failed", e);
  }
}

module.exports = { logActivityChange };

});
__define('mutate/logThought.js', function(module, exports, require) {
const { ensureLogFilesForDate } = require("./ensureFiles");

/**
 * Append a thought entry to the daily log and meta log.
 * @param {Object} state - PlannerState.
 * @param {Object} payload - Log details.
 * @param {string} payload.content - Note content.
 * @param {string} payload.source - Source label.
 * @returns {Promise<number|null>} Created note id.
 */
async function logThought(state, payload) {
  const { content, source } = payload;
  if (!content) return null;
  const date = state.currentPlannerDate;
  const ts = state.now.nowTime();
  const thoughtsFile = state.paths.getThoughtsFile(date);
  const metaLogFile = state.paths.getMetaLogFile(date);

  await ensureLogFilesForDate(state, date);
  const tTxt = await state.io.read(thoughtsFile);
  let maxId = 0;
  String(tTxt)
    .split("\n")
    .forEach((l) => {
      const m = l.match(/^\\|\\s*(\\d+)\\s*\\|/);
      if (m) maxId = Math.max(maxId, Number(m[1]));
    });
  const noteId = maxId + 1;

  const duration = Math.floor(performance.now() - state.highResStart);
  try {
    navigator.clipboard.writeText(content);
  } catch (e) {
    /* clipboard best-effort */
  }
  const cleanContent = String(content).replace(/\\|/g, "\\\\|").replace(/\\r?\\n/g, " ");
  await state.io.append(thoughtsFile, `| ${noteId} | ${cleanContent}  | ${ts} <t-${Math.floor(state.highResStart)}> |
`);
  await state.io.append(metaLogFile, `| ${noteId} | ${source} | ${duration} |
`);
  state.highResStart = performance.now();
  return noteId;
}

module.exports = { logThought };

});
__define('mutate/recordConsumption.js', function(module, exports, require) {
/**
 * Append a consumption entry, preserving split-range ids.
 * @param {Object} state - PlannerState.
 * @param {Object} payload - Consumption details.
 * @param {string} payload.item - Item name.
 * @param {string} payload.amount - Amount string.
 */
async function recordConsumption(state, payload) {
  const { item, amount } = payload;
  const dateStr = state.now.nowToday();
  const ts = state.now.nowTime();
  const file = state.consumptionLogFile;
  let fileContent = await state.io.read(file).catch(() => "");
  if (!fileContent) {
    fileContent = `| id | Date | Item | Time | Amount |
|---|---|---|---|---|
`;
    await state.io.ensureFile(file, fileContent);
  }
  const lines = String(fileContent).split("\n");
  let maxId = 0;
  lines.forEach((l) => {
    const m = l.match(/^\\|\\s*(\\d+)\\s*\\|/);
    if (m) maxId = Math.max(maxId, Number(m[1]));
  });
  const newId = state.device.isMobile ? (maxId < 100 ? 101 : maxId + 1) : maxId + 1;
  const row = `| ${newId} | ${dateStr} | ${item} | ${ts} | ${amount} |
`;
  await state.io.append(file, row);
  return { message: `Recorded: ${amount}x ${item} @ ${ts}` };
}

module.exports = { recordConsumption };

});
__define('mutate/requestStartWithOverlapCheck.js', function(module, exports, require) {
const { createActivityQueries } = require("../store/activityQueries");
const { startActivity } = require("./startActivity");

/**
 * Start an activity, optionally prompting when overlap is detected.
 * @param {Object} state - PlannerState.
 * @param {Object} payload - Start parameters.
 * @returns {Promise<Object>} Outcome describing whether a prompt is needed.
 */
async function requestStartWithOverlapCheck(state, payload) {
  const { activityName, startTime, plannedEndTime, existingRowId, preciseUnix, onRefresh } = payload;
  try {
    const queries = createActivityQueries(state);
    if (preciseUnix && String(state.currentPlannerDate) === state.now.nowDate()) {
      const active = await queries.getActiveActivities();
      const activeFiltered = active.filter((a) => a.name !== activityName);
      if (activeFiltered.length > 0) {
        return {
          needsPrompt: true,
          active: activeFiltered,
          request: { activityName, startTime, plannedEndTime, existingRowId, preciseUnix, onRefresh },
        };
      }
    }
    await startActivity(state, { activityName, startTime, plannedEndTime, existingRowId, preciseUnix, onRefresh });
    return { needsPrompt: false };
  } catch (e) {
    console.error("Overlap Check Error", e);
    return { needsPrompt: false };
  }
}

module.exports = { requestStartWithOverlapCheck };

});
__define('mutate/startActivity.js', function(module, exports, require) {
const { getNextTableId } = require("./getNextTableId");
const { ensurePrimaryAgendaFile } = require("./ensureFiles");
const { logActivityChange } = require("./logActivityChange");

/**
 * Start (or plan) an activity by writing to the agenda table.
 * @param {Object} state - PlannerState.
 * @param {Object} payload - Start parameters.
 * @param {string} payload.activityName - Activity title.
 * @param {string} payload.startTime - HH:mm string.
 * @param {string|null} [payload.plannedEndTime] - Optional planned end.
 * @param {string|null} [payload.existingRowId] - Existing id to overwrite.
 * @param {number|null} [payload.preciseUnix] - Optional unix tag.
 * @param {boolean} [payload.skipRefresh] - Skip embed refresh.
 * @param {Function} [payload.onRefresh] - Callback when refresh needed.
 */
async function startActivity(state, payload) {
  const {
    activityName,
    startTime,
    plannedEndTime = null,
    existingRowId = null,
    preciseUnix = null,
    skipRefresh = false,
    onRefresh,
  } = payload;

  try {
    await ensurePrimaryAgendaFile(state);
    const cleanTime = startTime;
    let unixTag = "";
    const startMins = state.time.timeToMins(cleanTime);
    const nowMins = state.time.timeToMins(state.now.nowTime());
    const todayStr = state.now.nowDate();
    const viewingToday = String(state.currentPlannerDate) === todayStr;
    const isFuturePlan = viewingToday && startMins > nowMins + 5;
    if (!isFuturePlan && viewingToday) {
      const ts = preciseUnix || state.time.getUnixFromString(cleanTime);
      unixTag = ` <u${ts}>`;
    }

    const content = await state.io.read(state.primaryAgendaFile);
    const lines = String(content).split("\n");
    while (lines.length > 0 && lines[lines.length - 1].trim() === "") lines.pop();

    let finalId = existingRowId;
    let finalEnd = plannedEndTime ? ` ${plannedEndTime} ` : `<end-${existingRowId}>`;

    if (existingRowId) {
      const rowIndex = lines.findIndex((l) => l.match(new RegExp(`^\\|\\s*${existingRowId}\\s*\\|`)));
      if (rowIndex !== -1) {
        const parts = lines[rowIndex].split("|");
        parts[3] = ` ${cleanTime}${unixTag} `.padEnd(10);
        lines[rowIndex] = parts.join("|");
        finalEnd = parts[4];
      } else {
        lines.push(`| ${existingRowId}    | ${activityName.padEnd(28)} | ${cleanTime}${unixTag} | ${finalEnd} |`);
      }
    } else {
      finalId = await getNextTableId(state, state.primaryAgendaFile);
      finalEnd = plannedEndTime ? ` ${plannedEndTime} ` : `<end-${finalId}>`;
      lines.push(`| ${finalId}    | ${activityName.padEnd(28)} | ${cleanTime}${unixTag} | ${finalEnd} |`);
    }

    await state.io.write(state.primaryAgendaFile, `${lines.join("\n")}\n`);
    await logActivityChange(state, { actId: finalId, name: activityName, startVal: cleanTime, endVal: finalEnd });
    if (!skipRefresh && typeof onRefresh === "function") {
      setTimeout(() => onRefresh(), 50);
    }
  } catch (e) {
    console.error("Start Error", e);
  }
}

module.exports = { startActivity };

});
__define('notify/checkNotifications.js', function(module, exports, require) {
const { buildUnifiedActivityMap } = require("../store/unifiedActivityMap");

/**
 * Gap detection alert logic reused by UI.
 * @param {Object} state - PlannerState.
 * @returns {Promise<{alert:string, active:boolean}>} Alert message (or empty).
 */
async function checkNotifications(state) {
  try {
    const unifiedMap = await buildUnifiedActivityMap(state);
    const nowMins = state.time.timeToMins(state.now.nowTime());
    let activeFound = false;
    let globalLastEnd = -1;

    unifiedMap.forEach((act) => {
      const startCol = act.start.replace(/<.*?>/g, "").trim();
      const endCol = act.end.replace(/<.*?>/g, "").trim();
      if (/^\\d{1,2}:\\d{2}/.test(startCol)) {
        const sMins = state.time.timeToMins(startCol);
        if (sMins <= nowMins) {
          let isEndFuture = true;
          if (/^\\d{1,2}:\\d{2}/.test(endCol)) {
            if (state.time.timeToMins(endCol) <= nowMins) isEndFuture = false;
          }
          if (isEndFuture) activeFound = true;
        }
        if (/^\\d{1,2}:\\d{2}/.test(endCol)) {
          const eMins = state.time.timeToMins(endCol);
          if (eMins <= nowMins && eMins > globalLastEnd) globalLastEnd = eMins;
        }
      }
    });

    let alertMsg = "";
    if (!activeFound && globalLastEnd !== -1) {
      const gap = nowMins - globalLastEnd;
      if (gap >= 10) alertMsg = `⚠️ No Activity for ${gap} min!`;
    }
    return { alert: alertMsg };
  } catch (e) {
    return { alert: "" };
  }
}

module.exports = { checkNotifications };

});
__define('parse/agendaRow.js', function(module, exports, require) {
const { Activity } = require("../model/Activity");

/**
 * Parse a standard agenda table line into an Activity.
 * @param {string} line - Markdown table row.
 * @param {string} sourceFile - File path for provenance.
 * @param {string} [sourceType] - Human readable source (Desktop/Mobile).
 * @returns {Activity|null}
 */
function parseAgendaRow(line, sourceFile, sourceType = "Desktop") {
  if (!line.trim().startsWith("|") || line.includes("**Activity**") || line.includes("---")) return null;
  const parts = line.split("|");
  if (parts.length < 5) return null;
  const id = parts[1].trim();
  if (!id) return null;
  const name = parts[2].trim();
  const start = parts[3].trim();
  const end = parts[4].trim();
  return Activity({ id, name, start, end, sourceFile, sourceType });
}

module.exports = { parseAgendaRow };

});
__define('parse/consumptionRow.js', function(module, exports, require) {
const { ConsumptionItem } = require("../model/ConsumptionItem");

/**
 * Parse a consumption log row into a ConsumptionItem.
 * @param {string} line - Markdown row.
 * @returns {ConsumptionItem|null}
 */
function parseConsumptionRow(line) {
  const match = line.match(
    /^\|\s*(\d+)\s*\|\s*(\d{4}-\d{2}-\d{2})\s*\|\s*(.*?)\s*\|\s*(\d{1,2}:\d{2})\s*\|\s*(.*?)\s*\|/
  );
  if (!match) return null;
  return ConsumptionItem({
    id: Number(match[1]),
    date: match[2],
    item: match[3].trim(),
    time: match[4],
    amount: match[5].trim(),
  });
}

module.exports = { parseConsumptionRow };

});
__define('parse/edLogRow.js', function(module, exports, require) {
const { EditEvent } = require("../model/EditEvent");

/**
 * Parse a single EdLog line.
 * @param {string} line - Markdown row.
 * @returns {EditEvent|null}
 */
function parseEdLogRow(line) {
  const regexLog =
    /\|\s*(\d+)\s*\|\s*(\d+)\s*\|\s*(\d{4}-\d{2}-\d{2})\s*\|\s*(\d{2}:\d{2})\s*\|\s*(.*?)\s*\|\s*(.*?)\s*\|\s*(.*?)\s*\|/;
  const match = regexLog.exec(line);
  if (!match) return null;
  return EditEvent({
    logId: Number(match[1]),
    activityId: match[2].trim(),
    date: match[3],
    time: match[4],
    activity: match[5].trim(),
    start: match[6].trim(),
    end: match[7].trim(),
  });
}

module.exports = { parseEdLogRow };

});
__define('parse/thoughtLogRow.js', function(module, exports, require) {
/**
 * Parse a Thoughts and Observations log row.
 * @param {string} line - Markdown table row.
 * @returns {Object|null} Parsed row with id/comment/time.
 */
function parseThoughtLogRow(line) {
  const match = line.match(/^\|\s*(\d+)\s*\|\s*(.*?)\s*\|\s*(\d{1,2}:\d{2})/);
  if (!match) return null;
  return { id: match[1], comment: match[2], time: match[3] };
}

module.exports = { parseThoughtLogRow };

});
__define('state/PlannerState.js', function(module, exports, require) {
const { createDeviceEnv } = require("../env/device");
const { createPathEnv } = require("../env/paths");
const { createIo } = require("../io/files");
const { createNowHelpers } = require("../time/now");
const { createTimeConversions } = require("../time/conversions");

/**
 * Build the shared planner state container. All mutable cross-module data
 * lives on this object to reduce accidental globals.
 * @param {Object} deps - Runtime dependencies.
 * @param {App} deps.app - Obsidian app instance.
 * @param {DataviewApi} deps.dv - Dataview API instance.
 * @param {Object} [deps.config] - Optional configuration overrides.
 * @returns {Object} PlannerState instance.
 */
function createPlannerState({ app, dv, config = {} }) {
  const now = createNowHelpers();
  const time = createTimeConversions();
  const device = createDeviceEnv({ app, forceMobile: !!config.FORCE_MOBILE_MODE });
  const paths = createPathEnv({ suffix: device.suffix });
  const io = createIo({ app });

  const currentPlannerDate = device.currentDate;

  const state = {
    app,
    dv,
    now,
    time,
    device,
    paths,
    io,
    config: { FORCE_MOBILE_MODE: !!config.FORCE_MOBILE_MODE },
    currentPlannerDate,
    primaryAgendaFile: paths.getPrimaryAgendaFile(currentPlannerDate),
    consumptionLogFile: paths.getConsumptionLogFile(currentPlannerDate),
    calState: { scale: 0.5, currentDate: null, nodes: [] },
    highResStart: performance.now(),
    uiState: {
      panelOpen: false,
      activeIndex: -1,
      suggestMode: "root",
      pending: {
        activity: null,
        action: null,
        startTime: null,
        existingId: null,
        editField: null,
        lastEditedTime: null,
        resumable: [],
        startRequest: null,
        currentStart: null,
        currentEnd: null,
        consumptionItem: null,
        preciseTimestamp: null,
        targetFile: null,
        partialTime: { h: null },
        tempStorage: { val1: null },
      },
      historyStack: [],
    },
  };

  return state;
}

module.exports = { createPlannerState };

});
__define('state/updateDate.js', function(module, exports, require) {
/**
 * Update planner date and derived file paths.
 * @param {Object} state - PlannerState instance.
 * @param {string} dateStr - Target date YYYY-MM-DD.
 * @returns {Object} Updated derived paths.
 */
function updatePlannerDate(state, dateStr) {
  state.currentPlannerDate = String(dateStr);
  state.primaryAgendaFile = state.paths.getPrimaryAgendaFile(state.currentPlannerDate);
  state.consumptionLogFile = state.paths.getConsumptionLogFile(state.currentPlannerDate);
  return {
    primaryAgendaFile: state.primaryAgendaFile,
    consumptionLogFile: state.consumptionLogFile,
  };
}

module.exports = { updatePlannerDate };

});
__define('store/activityQueries.js', function(module, exports, require) {
const { buildUnifiedActivityMap } = require("./unifiedActivityMap");

/**
 * Activity query helpers that operate on the unified activity map.
 * @param {Object} state - PlannerState.
 * @returns {Object} Query functions.
 */
function createActivityQueries(state) {
  const getActiveActivities = async () => {
    try {
      const unifiedMap = await buildUnifiedActivityMap(state);
      const active = [];
      const nowMins = state.time.timeToMins(state.now.nowTime());
      unifiedMap.forEach((act) => {
        const startCol = act.start.replace(/<.*?>/g, "").trim();
        const endCol = act.end.replace(/<.*?>/g, "").trim();
        if (startCol.startsWith("<start") || (/^\\d{1,2}:\\d{2}/.test(startCol) && state.time.timeToMins(startCol) > nowMins)) return;
        if (endCol.startsWith("<end") || endCol === "" || (/^\\d{1,2}:\\d{2}/.test(endCol) && state.time.timeToMins(endCol) > nowMins)) {
          active.push({ name: act.name, sourceFile: act.sourceFile });
        }
      });
      return active;
    } catch (e) {
      return [];
    }
  };

  const getPlannedActivities = async () => {
    try {
      const unifiedMap = await buildUnifiedActivityMap(state);
      const planned = [];
      const nowMins = state.time.timeToMins(state.now.nowTime());
      unifiedMap.forEach((act) => {
        const startVal = act.start.trim();
        let isPlanned = false;
        let planTimeDisplay = "Pending";
        if (startVal.startsWith("<start")) isPlanned = true;
        else if (/^\\d{1,2}:\\d{2}/.test(startVal)) {
          const cleanStart = startVal.replace(/<.*?>/g, "").trim();
          if (state.time.timeToMins(cleanStart) > nowMins) {
            isPlanned = true;
            planTimeDisplay = cleanStart;
          }
        }
        if (isPlanned) planned.push({ id: act.id, name: act.name, planTime: planTimeDisplay, sourceFile: act.sourceFile });
      });
      return planned;
    } catch (e) {
      return [];
    }
  };

  const getAllActivities = async () => {
    try {
      const unifiedMap = await buildUnifiedActivityMap(state);
      return Array.from(unifiedMap.values())
        .map((act) => {
          const s = act.start.replace(/<.*?>/g, "").trim() || "---";
          const e = act.end.replace(/<.*?>/g, "").trim() || "---";
          const sourceLabel = act.sourceFile.includes("_m") ? "(M)" : "(D)";
          return { id: act.id, name: act.name, start: s, end: e, display: `${act.name} ${sourceLabel}`, sourceFile: act.sourceFile };
        })
        .reverse();
    } catch (e) {
      return [];
    }
  };

  const getInterruptedActivitiesByUnix = async (interruptUnix, excludeNames = []) => {
    try {
      const unifiedMap = await buildUnifiedActivityMap(state);
      const targetTag = `<u${interruptUnix}>`;
      const candidates = [];
      unifiedMap.forEach((act) => {
        if (excludeNames.includes(act.name)) return;
        const endCol = act.end || "";
        if (!endCol.includes(targetTag)) return;
        let originalPlan = null;
        const tMatch = endCol.match(/<t(\\d{1,2}-\\d{2})>/);
        if (tMatch) originalPlan = tMatch[1].replace("-", ":");
        candidates.push({ name: act.name, endTime: originalPlan });
      });
      return candidates;
    } catch (e) {
      return [];
    }
  };

  return {
    getActiveActivities,
    getPlannedActivities,
    getAllActivities,
    getInterruptedActivitiesByUnix,
  };
}

module.exports = { createActivityQueries };

});
__define('store/dailyAgendaFiles.js', function(module, exports, require) {
/**
 * Resolve all agenda files for a given date (desktop + mobile variants).
 * @param {Object} state - PlannerState.
 * @param {string} dateStr - Target date (YYYY-MM-DD).
 * @returns {Promise<string[]>} Ordered list of file paths.
 */
async function getDailyAgendaFiles(state, dateStr) {
  const basePath = state.paths.AGENDA_BASE_PATH;
  try {
    const cleanPath = basePath.endsWith("/") ? basePath.slice(0, -1) : basePath;
    const folder = state.app.vault.getAbstractFileByPath(cleanPath);
    if (!folder || !folder.children) return [state.paths.getPrimaryAgendaFile(dateStr)];

    const primary = state.paths.getPrimaryAgendaFile(dateStr);
    const matches = folder.children
      .filter((f) => f.name.startsWith(dateStr) && f.name.includes("Agenda") && f.extension === "md")
      .map((f) => f.path)
      .sort((a, b) => {
        if (a === primary) return 1;
        if (b === primary) return -1;
        return a.localeCompare(b);
      });
    return matches.length > 0 ? matches : [primary];
  } catch (e) {
    return [state.paths.getPrimaryAgendaFile(dateStr)];
  }
}

module.exports = { getDailyAgendaFiles };

});
__define('store/referenceLists.js', function(module, exports, require) {
/**
 * Load reference lists (activities, consumption, key sentences) from markdown sources.
 * @param {Object} state - PlannerState.
 * @returns {Object} Accessors for reference data.
 */
function createReferenceLists(state) {
  const getStandardActivities = async () => {
    const targetPath = await state.io.resolveVaultPath(state.paths.ACTIVITY_LIST_PATH);
    try {
      const content = await state.io.read(targetPath);
      return content
        .split("\n")
        .map((l) => l.trim())
        .filter((l) => l.startsWith("- ") || l.startsWith("* "))
        .map((l) => l.substring(2).trim());
    } catch (e) {
      return ["Planning", "Coding", "Reading"];
    }
  };

  const getConsumptionItems = async () => {
    const targetPath = await state.io.resolveVaultPath(state.paths.CONSUMPTION_LIST_PATH);
    try {
      const content = await state.io.read(targetPath);
      return content
        .split("\n")
        .map((l) => l.trim())
        .filter((l) => l.startsWith("- ") || l.startsWith("* "))
        .map((l) => l.substring(2).trim());
    } catch (e) {
      return ["Water", "Coffee", "Tea"];
    }
  };

  const getKeySentences = async () => {
    const targetPath = await state.io.resolveVaultPath(state.paths.RELATED_FILES_PATH);
    try {
      const content = await state.io.read(targetPath);
      return content
        .split("\n")
        .map((l) => l.trim())
        .map((l) => l.match(/\\[\\[(.*?)\\]\\]/))
        .filter((m) => m)
        .map((m) => {
          const fullInner = m[1];
          const parts = fullInner.split("|");
          return { label: parts[1] || fullInner, value: `[[${fullInner}]]` };
        });
    } catch (e) {
      return [];
    }
  };

  return { getStandardActivities, getConsumptionItems, getKeySentences };
}

module.exports = { createReferenceLists };

});
__define('store/unifiedActivityMap.js', function(module, exports, require) {
const { parseAgendaRow } = require("../parse/agendaRow");
const { getDailyAgendaFiles } = require("./dailyAgendaFiles");

/**
 * Build unified activity map across all agenda files for the current date.
 * @param {Object} state - PlannerState.
 * @returns {Promise<Map<string, Object>>} Map of id -> Activity.
 */
async function buildUnifiedActivityMap(state) {
  const unified = new Map();
  const files = await getDailyAgendaFiles(state, state.currentPlannerDate);
  for (const file of files) {
    try {
      const path = file.path || file;
      if (await state.io.exists(path)) {
        const content = await state.io.read(path);
        const lines = String(content).split("\n");
        lines.forEach((line) => {
          const activity = parseAgendaRow(line, path, detectSourceType(path));
          if (!activity) return;
          if (activity.start === "DELETED" || activity.end === "DELETED") {
            if (unified.has(activity.id)) unified.delete(activity.id);
          } else {
            unified.set(activity.id, { ...activity, sourceFile: path });
          }
        });
      }
    } catch (e) {
      console.log("Skipping file:", file);
    }
  }
  return unified;
}

function detectSourceType(filePath) {
  if (!filePath) return "Desktop";
  if (filePath.includes("EdLog")) return "Log";
  if (filePath.includes("_m") || filePath.toLowerCase().includes("mobile")) return "Mobile";
  return "Desktop";
}

module.exports = { buildUnifiedActivityMap };

});
__define('time/conversions.js', function(module, exports, require) {
const { pad } = require("./pad");

/**
 * Convert time strings and minute counts between formats.
 * @returns {Object} Conversion helpers.
 */
function createTimeConversions() {
  const timeToMins = (value) => {
    const parts = String(value || "").split(":").map(Number);
    if (parts.length < 2 || Number.isNaN(parts[0]) || Number.isNaN(parts[1])) return NaN;
    return parts[0] * 60 + parts[1];
  };

  const minsToTime = (mins) => {
    let hours = Math.floor(mins / 60);
    const minutes = mins % 60;
    if (hours > 23) hours -= 24;
    return `${pad(hours)}:${pad(minutes)}`;
  };

  const getUnixFromString = (timeStr) => {
    const d = new Date();
    const [h, m] = String(timeStr || "").split(":").map(Number);
    d.setHours(h, m, 0, 0);
    return d.getTime();
  };

  return { timeToMins, minsToTime, getUnixFromString };
}

module.exports = { createTimeConversions };

});
__define('time/now.js', function(module, exports, require) {
const { pad } = require("./pad");

/**
 * Current date/time helpers used across the planner.
 * @returns {Object} Exposes formatted date, day, and time strings.
 */
function createNowHelpers() {
  const nowDate = () => {
    const d = new Date();
    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
  };

  const nowToday = () => {
    const d = new Date();
    return `${pad(d.getDate())}`;
  };

  const nowTime = () => {
    const d = new Date();
    return `${pad(d.getHours())}:${pad(d.getMinutes())}`;
  };

  return { nowDate, nowToday, nowTime };
}

module.exports = { createNowHelpers };

});
__define('time/pad.js', function(module, exports, require) {
/**
 * Pad a number with a leading zero to ensure two-digit formatting.
 * @param {number|string} value - Numeric value to pad.
 * @returns {string} Two-character string representation.
 */
function pad(value) {
  return String(value).padStart(2, "0");
}

module.exports = { pad };

});
__define('time/parseTime.js', function(module, exports, require) {
/**
 * Parse an HH:mm string into total minutes.
 * @param {string} str - Formatted time string.
 * @returns {number|null} Minutes or null when invalid.
 */
function parseTime(str) {
  if (!str) return null;
  const match = String(str).match(/(\d{1,2}):(\d{2})/);
  if (!match) return null;
  return parseInt(match[1], 10) * 60 + parseInt(match[2], 10);
}

module.exports = { parseTime };

});
__define('ui/calendar/drawCalendarView.js', function(module, exports, require) {
const { cvContainerStyle, cvControlStyle, cvGridLineStyle, cvTimeLabelStyle, cvBlockStyle, OFFSET_Y, PIXELS_PER_MIN, TEXT_HEIGHT_THRESHOLD } = require("./styles");

/**
 * Render calendar view blocks into the embed container.
 * @param {Object} state - PlannerState.
 * @param {HTMLElement} embedBox - Target container.
 */
function drawCalendarView(state, embedBox) {
  embedBox.innerHTML = "";

  const controls = embedBox.createEl("div");
  controls.style.cssText = cvControlStyle;

  controls.createEl("span", { text: "Zoom: ", style: "font-size:12px;" });
  const slider = controls.createEl("input");
  slider.type = "range";
  slider.min = "0.2";
  slider.max = "1.5";
  slider.step = "0.05";
  slider.value = state.calState.scale;
  slider.style.width = "150px";
  slider.style.cursor = "pointer";
  slider.addEventListener("input", (e) => {
    state.calState.scale = parseFloat(e.target.value);
    drawCalendarView(state, embedBox);
  });

  const viewport = embedBox.createEl("div");
  viewport.style.cssText = cvContainerStyle;

  const totalHeight = 1440 * PIXELS_PER_MIN * state.calState.scale;
  const contentWrapper = viewport.createEl("div");
  contentWrapper.style.height = `${totalHeight}px`;
  contentWrapper.style.position = "relative";
  contentWrapper.style.minWidth = `${4 * 340 * state.calState.scale + 100}px`;

  for (let h = 0; h < 24; h += 1) {
    const mins = h * 60;
    const y = mins * PIXELS_PER_MIN;
    const line = contentWrapper.createEl("div");
    line.style.cssText = cvGridLineStyle;
    line.style.top = `${y * state.calState.scale}px`;

    const label = contentWrapper.createEl("div", { text: `${h}:00` });
    label.style.cssText = cvTimeLabelStyle;
    label.style.top = `${y * state.calState.scale}px`;
  }

  const now = new Date();
  const isToday = state.currentPlannerDate === state.now.nowDate();
  if (isToday) {
    const nowMins = now.getHours() * 60 + now.getMinutes();
    const nowY = nowMins * PIXELS_PER_MIN;
    const nowLine = contentWrapper.createEl("div");
    nowLine.style.cssText = `
            position: absolute; left: 50px; right: 0; 
            top: ${nowY * state.calState.scale}px; border-top: 2px solid red; z-index: 10; pointer-events: none;
        `;
    setTimeout(() => {
      viewport.scrollTop = nowY * state.calState.scale - 300;
    }, 50);
  }

  if (state.calState.nodes.length === 0) {
    contentWrapper.createEl("div", { text: "No activities found." }).style.padding = "50px";
  }

  state.calState.nodes.forEach((node) => {
    const renderHeight = node.height * state.calState.scale;
    const block = contentWrapper.createEl("div");
    block.style.cssText = cvBlockStyle(node.y, node.height, node.color, node.colIndex, state.calState.scale);
    block.title = `${node.text} (Source: ${node.sourceType})`;

    const startMins = (node.y - OFFSET_Y) / PIXELS_PER_MIN;
    const durationMins = node.height / PIXELS_PER_MIN;
    const endMins = startMins + durationMins;

    const timeStr = `${minutesToTime(startMins)} - ${minutesToTime(endMins)}`;
    const durationStr = `${Math.round(durationMins)} min`;

    if (renderHeight >= TEXT_HEIGHT_THRESHOLD) {
      block.innerHTML = `
                <strong>${node.text}</strong><br>
                <span style="opacity:0.8; font-size:0.9em">${timeStr}</span><br>
                <span style="opacity:0.6; font-size:0.8em">${durationStr}</span>
            `;
    } else {
      block.style.opacity = "0.6";
    }

    block.style.cursor = "pointer";
    block.onclick = async () => {
      const leaf = state.app.workspace.getLeaf("tab");
      await leaf.openFile(node.sourceFile);
    };
  });
}

function minutesToTime(totalMins) {
  const h = Math.floor(totalMins / 60);
  const m = Math.floor(totalMins % 60);
  return `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}`;
}

module.exports = { drawCalendarView };

});
__define('ui/calendar/loadCalendarData.js', function(module, exports, require) {
const { parseTime } = require("../../time/parseTime");
const { createTimeConversions } = require("../../time/conversions");
const { OFFSET_Y, PIXELS_PER_MIN } = require("./styles");
const { getDailyAgendaFiles } = require("../../store/dailyAgendaFiles");
const { parseAgendaRow } = require("../../parse/agendaRow");
const { parseEdLogRow } = require("../../parse/edLogRow");

const timeConversions = createTimeConversions();

/**
 * Load calendar nodes for a given date into state.calState.
 * @param {Object} state - PlannerState.
 * @param {string} dateStr - Target date.
 */
async function loadCalendarData(state, dateStr) {
  state.calState.currentDate = dateStr;
  state.calState.nodes = [];

  const folder = state.app.vault.getAbstractFileByPath(state.paths.AGENDA_BASE_PATH.slice(0, -1));
  if (!folder || !folder.children) return;

  const files = folder.children.filter((f) => f.extension === "md" && f.name.includes(dateStr));
  if (files.length === 0) return;

  const candidates = new Map();
  const agendaFiles = await getDailyAgendaFiles(state, dateStr);

  for (const file of files) {
    const isLog = file.name.includes("EdLog");
    const isMobile = file.name.includes("_m") || file.name.includes("Mobile");
    const content = await state.io.read(file.path || file);
    const lines = content.split("\n");

    for (const line of lines) {
      let actId;
      let activityRaw;
      let startStr;
      let endStr;
      let timestamp;

      if (isLog) {
        const parsed = parseEdLogRow(line);
        if (!parsed) continue;
        actId = parsed.activityId;
        activityRaw = parsed.activity;
        startStr = parsed.start;
        endStr = parsed.end;
        timestamp = new Date(`${parsed.date}T${parsed.time}`).getTime();
      } else {
        const parsed = parseAgendaRow(line, file.path || file, isMobile ? "Mobile" : "Desktop");
        if (!parsed) continue;
        actId = parsed.id;
        activityRaw = parsed.name;
        startStr = parsed.start;
        endStr = parsed.end;
        timestamp = 0;
      }

      const startMins = parseTime(startStr);
      const endMins = parseTime(endStr);

      const displayTitle = String(activityRaw)
        .replace(/\\[\\[.*?\\|(.*?)\\]\\]/, "$1")
        .replace(/\\[\\[(.*?)\\]\\]/, "$1")
        .replace(/^[#\\s]+/, "")
        .replace(/<.*?>/, "???");

      if (startMins !== null) {
        if (!candidates.has(actId)) candidates.set(actId, []);
        candidates.get(actId).push({
          id: actId,
          text: displayTitle,
          startMins,
          endMins,
          timestamp,
          source: isLog ? "Log" : isMobile ? "Mobile" : "Desktop",
          file,
        });
      }
    }
  }

  const now = new Date();
  const todayStr = now.toISOString().slice(0, 10);
  const currentMins = now.getHours() * 60 + now.getMinutes();

  candidates.forEach((entries) => {
    entries.sort((a, b) => b.timestamp - a.timestamp);
    const winner = entries[0];
    let finalEnd = winner.endMins;

    if (finalEnd === null) {
      if (dateStr === todayStr && winner.startMins < currentMins) {
        finalEnd = Math.max(currentMins, winner.startMins + 30);
      } else {
        finalEnd = winner.startMins + 60;
      }
    }

    const duration = finalEnd - winner.startMins;
    if (duration > 0) {
      let blockColor = "#54B5FB";
      if (winner.source === "Log") blockColor = "#FFB86C";
      else if (winner.source === "Mobile") blockColor = "#bd93f9";

      state.calState.nodes.push({
        id: winner.id,
        text: winner.text,
        y: winner.startMins * PIXELS_PER_MIN + OFFSET_Y,
        height: duration * PIXELS_PER_MIN,
        color: blockColor,
        colIndex: 0,
        sourceFile: winner.file,
        sourceType: winner.source,
      });
    }
  });

  state.calState.nodes.sort((a, b) => a.y - b.y);
  const colEnds = [0, 0, 0, 0];

  state.calState.nodes.forEach((node) => {
    let bestCol = 0;
    let maxGap = -1;
    let foundValid = false;
    for (let i = 0; i < 4; i += 1) {
      if (node.y >= colEnds[i] - 5) {
        const gap = node.y - colEnds[i];
        if (gap > maxGap) {
          maxGap = gap;
          bestCol = i;
          foundValid = true;
        }
      }
    }
    if (!foundValid) {
      let minEnd = colEnds[0];
      for (let i = 1; i < 4; i += 1) {
        if (colEnds[i] < minEnd) {
          minEnd = colEnds[i];
          bestCol = i;
        }
      }
    }
    node.colIndex = bestCol;
    colEnds[bestCol] = node.y + node.height;
  });
}

module.exports = { loadCalendarData };

});
__define('ui/calendar/refreshEmbed.js', function(module, exports, require) {
const { loadCalendarData } = require("./loadCalendarData");
const { drawCalendarView } = require("./drawCalendarView");

/**
 * Load calendar nodes then draw into the embed container.
 * @param {Object} state - PlannerState.
 * @param {HTMLElement} embedBox - Target element.
 */
async function refreshEmbed(state, embedBox) {
  await loadCalendarData(state, state.currentPlannerDate);
  drawCalendarView(state, embedBox);
}

module.exports = { refreshEmbed };

});
__define('ui/calendar/styles.js', function(module, exports, require) {
/**
 * Calendar view style snippets reused across rendering functions.
 */
const OFFSET_Y = 100;
const PIXELS_PER_MIN = 3;
const COL_SPACING = 340;
const TEXT_HEIGHT_THRESHOLD = 30;

const cvContainerStyle = `
  position: relative;
  width: 100%;
  height: 600px; 
  background: var(--background-primary);
  border: 1px solid var(--background-modifier-border);
  border-radius: 8px;
  overflow: auto;
  font-family: var(--font-interface);
  margin-top: 5px;
`;

const cvControlStyle = `
  display: flex; 
  gap: 15px; 
  margin-bottom: 5px; 
  align-items: center;
  font-family: var(--font-interface);
  background: var(--background-secondary);
  padding: 8px;
  border-radius: 8px;
`;

const cvGridLineStyle = `
  position: absolute;
  left: 50px; right: 0;
  border-top: 1px solid var(--background-modifier-border);
  opacity: 0.3;
  pointer-events: none;
`;

const cvTimeLabelStyle = `
  position: absolute;
  left: 4px;
  width: 40px;
  text-align: right;
  font-size: 10px;
  color: var(--text-muted);
  transform: translateY(-50%);
`;

const cvBlockStyle = (y, h, color, colIndex, scale) => `
  position: absolute;
  left: ${(colIndex * COL_SPACING * scale) + 60}px; 
  top: ${(y - OFFSET_Y) * scale}px;
  width: ${320 * scale}px;
  height: ${h * scale}px;
  background-color: ${color}33; 
  border-left: 3px solid ${color};
  padding: 4px;
  font-size: ${12 * (scale < 0.6 ? 0.8 : 1)}px;
  overflow: hidden;
  border-radius: 4px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  color: var(--text-normal);
  line-height: 1.2;
  white-space: nowrap; 
  text-overflow: ellipsis;
  z-index: 5;
`;

module.exports = {
  OFFSET_Y,
  PIXELS_PER_MIN,
  COL_SPACING,
  TEXT_HEIGHT_THRESHOLD,
  cvContainerStyle,
  cvControlStyle,
  cvGridLineStyle,
  cvTimeLabelStyle,
  cvBlockStyle,
};

});
__define('ui/logPanel.js', function(module, exports, require) {
const { ensureLogFilesForDate } = require("../mutate/ensureFiles");
const { parseThoughtLogRow } = require("../parse/thoughtLogRow");

/**
 * Render the thoughts log into the UI list.
 * @param {Object} state - PlannerState.
 * @param {HTMLElement} logBox - Target container.
 */
async function refreshThoughtLog(state, logBox) {
  const date = state.currentPlannerDate;
  await ensureLogFilesForDate(state, date);
  const thoughtsFile = state.paths.getThoughtsFile(date);
  const txt = await state.io.read(thoughtsFile).catch(() => null);
  logBox.innerHTML = "";
  if (!txt) return;
  const rows = [];
  String(txt)
    .split("\n")
    .forEach((line) => {
      const row = parseThoughtLogRow(line);
      if (row) rows.push(row);
    });
  rows
    .slice(-50)
    .reverse()
    .forEach((r) => {
      const msg = logBox.createEl("div", { cls: "msg" });
      msg.createEl("div", { cls: "meta", text: `- ${r.comment} (${r.time}-${r.id})` });
    });
  logBox.scrollTop = logBox.scrollHeight;
}

module.exports = { refreshThoughtLog };

});
__define('ui/suggester/suggester.js', function(module, exports, require) {
const { requestStartWithOverlapCheck } = require("../../mutate/requestStartWithOverlapCheck");
const { startActivity } = require("../../mutate/startActivity");
const { endActivity } = require("../../mutate/endActivity");
const { editActivity } = require("../../mutate/editActivity");
const { deleteActivity } = require("../../mutate/deleteActivity");
const { recordConsumption } = require("../../mutate/recordConsumption");
const { createActivityQueries } = require("../../store/activityQueries");
const { createReferenceLists } = require("../../store/referenceLists");

const PROMPT_SINGLE = ["Tyrosine", "Tryptophan"];
const PROMPT_DOUBLE = ["Beer", "Wine"];

/**
 * State machine driving the suggester UI/keyboard flows.
 * @param {Object} state - PlannerState.
 * @param {Object} ui - DOM references.
 * @param {HTMLElement} ui.textBox - Textarea used for input.
 * @param {HTMLElement} ui.taskBox - Element used for inline notices.
 * @param {HTMLElement} ui.panelHost - Container for the panel (document.body).
 * @param {Function} refreshEmbed - Calendar refresh function.
 * @returns {Object} Suggester API.
 */
function createSuggester(state, ui, refreshEmbed) {
  const queries = createActivityQueries(state);
  const lists = createReferenceLists(state);

  const panel = document.createElement("div");
  panel.className = "suggest-panel";
  panel.style.display = "none";
  panel.innerHTML = `<div class="suggest-head"><div class="suggest-bc"></div><div class="suggest-nav"><button class="nav-btn" id="nav-back">←</button><button class="nav-btn" id="nav-fwd">→</button></div></div><div class="suggest-list"></div>`;
  ui.panelHost.appendChild(panel);
  const bcEl = panel.querySelector(".suggest-bc");
  const listEl = panel.querySelector(".suggest-list");
  const backBtn = panel.querySelector("#nav-back");
  const fwdBtn = panel.querySelector("#nav-fwd");

  const getPending = () => state.uiState.pending;

  function closePanel() {
    panel.style.display = "none";
    state.uiState.panelOpen = false;
    state.uiState.activeIndex = -1;
    state.uiState.historyStack = [];
  }

  async function processStartRequest(params) {
    const res = await requestStartWithOverlapCheck(state, { ...params, onRefresh: refreshEmbed });
    if (res.needsPrompt) {
      getPending().startRequest = res.request;
      state.uiState.suggestMode = "agenda-start-overlap";
      panel.style.display = "block";
      state.uiState.panelOpen = true;
      reposition();
      await rerender();
      setTimeout(() => ui.textBox.focus(), 0);
      return true;
    }
    return false;
  }

  function reposition() {
    const r = ui.textBox.getBoundingClientRect();
    const y = Math.min(r.bottom - 8, window.innerHeight - 300);
    panel.style.left = `${r.left + 12}px`;
    panel.style.top = `${y}px`;
    panel.style.minWidth = `${Math.max(320, r.width * 0.6)}px`;
  }

  function setActive(i) {
    const items = listEl.querySelectorAll(".suggest-item");
    items.forEach((x) => x.classList.remove("active"));
    if (i >= 0 && i < items.length) {
      items[i].classList.add("active");
      items[i].scrollIntoView({ block: "nearest" });
      state.uiState.activeIndex = i;
    }
  }

  function createItem(icon, label) {
    const d = document.createElement("div");
    d.className = "suggest-item";
    d.innerHTML = `<span class="suggest-icon">${icon}</span><span>${label}</span>`;
    return d;
  }

  function setAgendaTitle(title) {
    const mode = String(state.uiState.suggestMode || "");
    if (mode.startsWith("agenda-") && !mode.startsWith("agenda-consumption") && mode !== "agenda-keysentences") {
      bcEl.innerHTML = `<div style="font-size:12px;opacity:0.75;line-height:1.1;margin-bottom:2px;">${state.currentPlannerDate}</div><div>${title}</div>`;
    } else {
      bcEl.textContent = title;
    }
  }

  function pushHistory() {
    const p = getPending();
    state.uiState.historyStack.push({
      mode: state.uiState.suggestMode,
      pending: JSON.parse(JSON.stringify(p)),
    });
  }

  function restoreHistory() {
    if (state.uiState.historyStack.length === 0) {
      closePanel();
      return;
    }
    const snap = state.uiState.historyStack.pop();
    state.uiState.suggestMode = snap.mode;
    state.uiState.pending = { ...state.uiState.pending, ...snap.pending };
    rerender();
  }

  function triggerForward() {
    const items = listEl.querySelectorAll(".suggest-item");
    if (state.uiState.activeIndex >= 0 && state.uiState.activeIndex < items.length) {
      const selected = items[state.uiState.activeIndex];
      const data = {
        code: selected.dataset.code,
        value: selected.dataset.value,
        time: selected.dataset.time,
        custom: selected.dataset.custom === "true",
        method: selected.dataset.method,
        id: selected.dataset.id,
        precise: selected.dataset.precise === "true",
        field: selected.dataset.field,
        choice: selected.dataset.choice,
        start: selected.dataset.start,
        end: selected.dataset.end,
        file: selected.dataset.file,
      };
      selectItem(data);
    }
  }

  backBtn.addEventListener("mousedown", (e) => {
    e.preventDefault();
    restoreHistory();
  });
  fwdBtn.addEventListener("mousedown", (e) => {
    e.preventDefault();
    triggerForward();
  });

  async function rerender() {
    try {
      listEl.innerHTML = "";
      let query = ui.textBox.value.trim().toLowerCase();
      if (state.uiState.suggestMode === "agenda-keysentences") {
        const anchor = findDotCommaAnchor();
        query = anchor !== null ? ui.textBox.value.substring(anchor + 2, ui.textBox.selectionStart).toLowerCase() : "";
      }

      if (state.uiState.suggestMode === "agenda-root") {
        setAgendaTitle("Agenda Actions");
        [
          { l: "Start Activity", i: "▶️", c: "start" },
          { l: "End Activity", i: "⏹️", c: "end" },
          { l: "Edit Activity", i: "✏️", c: "edit" },
          { l: "Delete Activity", i: "🗑️", c: "delete" },
        ].forEach((it) => {
          const d = document.createElement("div");
          d.className = "suggest-item";
          d.innerHTML = `<span class="suggest-icon">${it.i}</span><span>${it.l}</span>`;
          d.dataset.code = it.c;
          d.addEventListener("mousedown", () => selectItem({ code: it.c }));
          listEl.appendChild(d);
        });
      } else if (state.uiState.suggestMode === "agenda-select-activity" || state.uiState.suggestMode === "agenda-consumption-select") {
        let items = [];
        if (state.uiState.suggestMode === "agenda-consumption-select") {
          setAgendaTitle("What did you consume?");
          const list = await lists.getConsumptionItems();
          list.forEach((i) => items.push({ name: i, id: null, label: i, extra: "", icon: "💊" }));
        } else if (getPending().action === "start") {
          setAgendaTitle("Select Activity");
          const planned = await queries.getPlannedActivities();
          if (planned.length > 0) {
            const title = document.createElement("div");
            title.className = "suggest-section-title";
            title.textContent = "📅 Planned";
            listEl.appendChild(title);
            planned.forEach((p) => items.push({ name: p.name, id: p.id, label: p.name, extra: p.planTime, icon: "🎯" }));
          }
          const dynamicActivities = await lists.getStandardActivities();
          if (items.length > 0) {
            const title = document.createElement("div");
            title.className = "suggest-section-title";
            title.textContent = "📂 All";
            listEl.appendChild(title);
          }
          dynamicActivities.forEach((a) => items.push({ name: a, id: null, label: a, extra: "", icon: "🏁" }));
        } else if (getPending().action === "end") {
          setAgendaTitle("End which activity?");
          const active = await queries.getActiveActivities();
          active.forEach((a) => items.push({ name: a.name, id: null, label: a.name, extra: "", icon: "⏹️", file: a.sourceFile }));
        } else if (getPending().action === "edit") {
          setAgendaTitle("Edit which activity?");
          const all = await queries.getAllActivities();
          all.forEach((a) => items.push({ name: a.name, id: a.id, label: a.name, extra: `${a.start}-${a.end}`, icon: "✏️", start: a.start, end: a.end, file: a.sourceFile }));
        } else if (getPending().action === "delete") {
          setAgendaTitle("Delete which activity?");
          const all = await queries.getAllActivities();
          all.forEach((a) => items.push({ name: a.name, id: a.id, label: a.name, extra: `${a.start}-${a.end}`, icon: "🗑️", file: a.sourceFile }));
        }
        const matches = items.filter((i) => i.label.toLowerCase().includes(query));
        if (matches.length === 0) listEl.innerHTML = '<div class="suggest-item">No matches</div>';
        matches.forEach((m) => {
          const d = document.createElement("div");
          d.className = "suggest-item";
          d.innerHTML = `<span class="suggest-icon">${m.icon}</span><span>${m.label}</span> <small style="float:right">${m.extra}</small>`;
          d.dataset.value = m.name;
          if (m.id) d.dataset.id = String(m.id);
          if (m.start) d.dataset.start = m.start;
          if (m.end) d.dataset.end = m.end;
          if (m.file) d.dataset.file = m.file;
          d.addEventListener("mousedown", () => selectItem({ value: m.name, id: m.id, start: m.start, end: m.end, file: m.file }));
          listEl.appendChild(d);
        });
      } else if (state.uiState.suggestMode === "agenda-keysentences") {
        setAgendaTitle("Insert Key Sentence");
        const sentences = await lists.getKeySentences();
        const matches = sentences.filter((s) => s.label.toLowerCase().includes(query));
        if (matches.length === 0) listEl.innerHTML = '<div class="suggest-item">No matches</div>';
        matches.forEach((s) => {
          const d = document.createElement("div");
          d.className = "suggest-item";
          d.innerHTML = `<span class="suggest-icon">📝</span><span>${s.label}</span>`;
          d.dataset.value = s.value;
          d.addEventListener("mousedown", () => selectItem({ value: s.value, code: "insert-sentence" }));
          listEl.appendChild(d);
        });
      } else if (state.uiState.suggestMode === "agenda-consumption-amount") {
        setAgendaTitle(`How much ${getPending().consumptionItem}?`);
        const hint = document.createElement("div");
        hint.className = "suggest-input-hint";
        hint.innerHTML = ui.textBox.value ? `Press Enter for: <b>${ui.textBox.value}</b>` : "Type amount (Default: 1)";
        listEl.appendChild(hint);
      } else if (state.uiState.suggestMode === "agenda-consumption-double-1") {
        setAgendaTitle(`${getPending().consumptionItem}: Amount/Volume?`);
        const hint = document.createElement("div");
        hint.className = "suggest-input-hint";
        hint.innerHTML = ui.textBox.value ? `Press Enter for: <b>${ui.textBox.value}</b>` : "e.g. 500ml, 1 Pint";
        listEl.appendChild(hint);
      } else if (state.uiState.suggestMode === "agenda-consumption-double-2") {
        setAgendaTitle(`${getPending().consumptionItem}: % / Type / Notes?`);
        const hint = document.createElement("div");
        hint.className = "suggest-input-hint";
        hint.innerHTML = ui.textBox.value ? `Press Enter for: <b>${ui.textBox.value}</b>` : "e.g. 5%, IPA, etc";
        listEl.appendChild(hint);
      } else if (state.uiState.suggestMode === "agenda-edit-field") {
        setAgendaTitle(`Edit "${getPending().activity}" (${getPending().currentStart || "?"} - ${getPending().currentEnd || "?"})`);
        [
          { l: "Start Time", v: "start", i: "🕒" },
          { l: "End Time", v: "end", i: "🏁" },
          { l: "Rename Activity", v: "name", i: "Aa" },
        ].forEach((f) => {
          const d = document.createElement("div");
          d.className = "suggest-item";
          d.innerHTML = `<span class="suggest-icon">${f.i}</span><span>${f.l}</span>`;
          d.dataset.field = f.v;
          d.addEventListener("mousedown", () => selectItem({ field: f.v }));
          listEl.appendChild(d);
        });
      } else if (state.uiState.suggestMode === "agenda-rename-input") {
        setAgendaTitle(`Rename "${getPending().activity}" to...`);
        const typeHint = document.createElement("div");
        typeHint.className = "suggest-input-hint";
        typeHint.innerHTML = ui.textBox.value ? `Press Enter to rename to: <b>${ui.textBox.value}</b>` : "Type new name...";
        listEl.appendChild(typeHint);
        const dynamicActivities = await lists.getStandardActivities();
        const matches = dynamicActivities.filter((a) => a.toLowerCase().includes(query));
        matches.forEach((name) => {
          const d = document.createElement("div");
          d.className = "suggest-item";
          d.innerHTML = `<span class="suggest-icon">🏷️</span><span>${name}</span>`;
          d.dataset.value = name;
          d.addEventListener("mousedown", () => selectItem({ value: name }));
          listEl.appendChild(d);
        });
      } else if (state.uiState.suggestMode === "agenda-edit-chain") {
        const otherField = getPending().editField === "start" ? "End" : "Start";
        setAgendaTitle(`Edited ${getPending().editField}. Also edit ${otherField}?`);
        const d1 = document.createElement("div");
        d1.className = "suggest-item";
        d1.innerHTML = `<span class="suggest-icon">✅</span><span>No, I'm done</span>`;
        d1.dataset.choice = "done";
        d1.addEventListener("mousedown", () => selectItem({ choice: "done" }));
        listEl.appendChild(d1);
        const d2 = document.createElement("div");
        d2.className = "suggest-item";
        d2.innerHTML = `<span class="suggest-icon">✏️</span><span>Yes, Edit ${otherField}</span>`;
        d2.dataset.choice = "edit_other";
        d2.addEventListener("mousedown", () => selectItem({ choice: "edit_other" }));
        listEl.appendChild(d2);
      } else if (state.uiState.suggestMode === "agenda-edit-method") {
        setAgendaTitle(`How to set ${getPending().editField}?`);
        const d1 = document.createElement("div");
        d1.className = "suggest-item";
        d1.innerHTML = `<span class="suggest-icon">⌨️</span><span>Set Time</span>`;
        d1.dataset.method = "time";
        d1.addEventListener("mousedown", () => selectItem({ method: "time" }));
        listEl.appendChild(d1);
        const d2 = document.createElement("div");
        d2.className = "suggest-item";
        d2.innerHTML = `<span class="suggest-icon">⏳</span><span>Duration (min)</span>`;
        d2.dataset.method = "duration";
        d2.addEventListener("mousedown", () => selectItem({ method: "duration" }));
        listEl.appendChild(d2);
      } else if (state.uiState.suggestMode === "agenda-start-overlap") {
        const act = getPending().startRequest?.activityName || getPending().activity || "Activity";
        setAgendaTitle(`Start "${act}" — end active task(s)?`);
        const y = document.createElement("div");
        y.className = "suggest-item";
        y.innerHTML = `<span class="suggest-icon">🧹</span><span>Yes — end & start</span>`;
        y.dataset.choice = "overlap_yes";
        y.addEventListener("mousedown", () => selectItem({ choice: "overlap_yes" }));
        listEl.appendChild(y);
        const n = document.createElement("div");
        n.className = "suggest-item";
        n.innerHTML = `<span class="suggest-icon">🧬</span><span>No — multitask</span>`;
        n.dataset.choice = "overlap_no";
        n.addEventListener("mousedown", () => selectItem({ choice: "overlap_no" }));
        listEl.appendChild(n);
        const c = document.createElement("div");
        c.className = "suggest-item";
        c.innerHTML = `<span class="suggest-icon">↩️</span><span>Cancel</span>`;
        c.dataset.choice = "overlap_cancel";
        c.addEventListener("mousedown", () => selectItem({ choice: "overlap_cancel" }));
        listEl.appendChild(c);
      } else if (state.uiState.suggestMode === "agenda-resume") {
        setAgendaTitle("Resume interrupted activities?");
        const names = (getPending().resumable || []).map((a) => a.name).join(", ");
        const hint = document.createElement("div");
        hint.className = "suggest-input-hint";
        hint.textContent = `Interrupted: ${names}`;
        listEl.appendChild(hint);
        const y = document.createElement("div");
        y.className = "suggest-item";
        y.innerHTML = `<span class="suggest-icon">🔄</span><span>Yes, Resume</span>`;
        y.dataset.choice = "resume_yes";
        y.addEventListener("mousedown", () => selectItem({ choice: "resume_yes" }));
        listEl.appendChild(y);
        const n = document.createElement("div");
        n.className = "suggest-item";
        n.innerHTML = `<span class="suggest-icon">⏹️</span><span>No, just end break</span>`;
        n.dataset.choice = "resume_no";
        n.addEventListener("mousedown", () => selectItem({ choice: "resume_no" }));
        listEl.appendChild(n);
      } else if (state.uiState.suggestMode === "agenda-delete-confirm") {
        setAgendaTitle(`DELETE "${getPending().activity}"?`);
        const y = document.createElement("div");
        y.className = "suggest-item";
        y.innerHTML = `<span class="suggest-icon">🗑️</span><span>Yes, Delete it</span>`;
        y.dataset.choice = "delete_yes";
        y.addEventListener("mousedown", () => selectItem({ choice: "delete_yes" }));
        listEl.appendChild(y);
        const n = document.createElement("div");
        n.className = "suggest-item";
        n.innerHTML = `<span class="suggest-icon">↩️</span><span>No, Cancel</span>`;
        n.dataset.choice = "delete_no";
        n.addEventListener("mousedown", () => selectItem({ choice: "delete_no" }));
        listEl.appendChild(n);
      } else if (state.uiState.suggestMode === "agenda-time-select") {
        setAgendaTitle("Set Time");
        const nowStr = state.now.nowTime();
        const d1 = createItem("⏱️", `Now (${nowStr})`);
        d1.dataset.time = nowStr;
        d1.dataset.precise = "true";
        d1.addEventListener("mousedown", () => selectItem({ time: nowStr, precise: true }));
        listEl.appendChild(d1);
        const d2 = createItem("⌨️", "Custom.");
        d2.dataset.custom = "true";
        d2.addEventListener("mousedown", () => selectItem({ custom: true }));
        listEl.appendChild(d2);
      } else if (state.uiState.suggestMode === "agenda-plan-method") {
        setAgendaTitle("Plan End");
        const d1 = createItem("⏳", "Duration (min)");
        d1.dataset.method = "duration";
        d1.addEventListener("mousedown", () => selectItem({ method: "duration" }));
        listEl.appendChild(d1);
        const d2 = createItem("🔚", "Set End Time");
        d2.dataset.method = "manual";
        d2.addEventListener("mousedown", () => selectItem({ method: "manual" }));
        listEl.appendChild(d2);
        const d3 = createItem("🔓", "Open End");
        d3.dataset.method = "open";
        d3.addEventListener("mousedown", () => selectItem({ method: "open" }));
        listEl.appendChild(d3);
      }
      const items = listEl.querySelectorAll(".suggest-item");
      if (items.length > 0) setActive(0);
    } catch (e) {
      console.error("Rerender Error", e);
    }
  }

  function closeAndClear() {
    ui.textBox.value = "";
    ui.textBox.placeholder = "Type ";
    closePanel();
  }

  async function selectItem(data) {
    pushHistory();
    const pending = getPending();
    if (state.uiState.suggestMode === "agenda-root") {
      pending.action = data.code;
      state.uiState.suggestMode = "agenda-select-activity";
      ui.textBox.value = "";
      rerender();
    } else if (state.uiState.suggestMode === "agenda-keysentences") {
      if (data.value) {
        const anchor = findDotCommaAnchor();
        if (anchor !== null) {
          const before = ui.textBox.value.substring(0, anchor);
          const after = ui.textBox.value.substring(ui.textBox.selectionStart);
          ui.textBox.value = before + data.value + after;
          const newCursor = before.length + data.value.length;
          ui.textBox.setSelectionRange(newCursor, newCursor);
        }
        closePanel();
        ui.textBox.focus();
      }
    } else if (state.uiState.suggestMode === "agenda-select-activity") {
      const val = data.value || listEl.children[state.uiState.activeIndex]?.dataset.value;
      const id = data.id && data.id !== "undefined" ? data.id : null;
      const file = data.file;
      if (val) {
        pending.activity = val;
        pending.existingId = id;
        pending.targetFile = file;
        if (pending.action === "edit") {
          pending.currentStart = data.start;
          pending.currentEnd = data.end;
          state.uiState.suggestMode = "agenda-edit-field";
        } else if (pending.action === "delete") {
          state.uiState.suggestMode = "agenda-delete-confirm";
        } else {
          state.uiState.suggestMode = "agenda-time-select";
        }
        ui.textBox.value = "";
        rerender();
      }
    } else if (state.uiState.suggestMode === "agenda-consumption-select") {
      const val = data.value;
      if (val) {
        pending.consumptionItem = val;
        if (PROMPT_DOUBLE.includes(val)) {
          state.uiState.suggestMode = "agenda-consumption-double-1";
          ui.textBox.value = "";
          ui.textBox.placeholder = "First Val";
          rerender();
        } else if (PROMPT_SINGLE.includes(val)) {
          state.uiState.suggestMode = "agenda-consumption-amount";
          ui.textBox.value = "";
          ui.textBox.placeholder = "1";
          rerender();
        } else {
          await recordConsumption(state, { item: val, amount: "1" });
          closeAndClear();
        }
      }
    } else if (state.uiState.suggestMode === "agenda-edit-field") {
      pending.editField = data.field;
      state.uiState.suggestMode = pending.editField === "name" ? "agenda-rename-input" : "agenda-time-select";
      rerender();
    } else if (state.uiState.suggestMode === "agenda-rename-input") {
      const newVal = data.value || ui.textBox.value.trim();
      if (newVal) {
        await editActivity(state, { rowId: pending.existingId, field: "name", newVal, targetFile: pending.targetFile, onRefresh: refreshEmbed });
        closeAndClear();
      }
    } else if (state.uiState.suggestMode === "agenda-edit-chain") {
      if (data.choice === "done") closeAndClear();
      else {
        pending.editField = pending.editField === "start" ? "end" : "start";
        state.uiState.suggestMode = "agenda-edit-method";
        rerender();
      }
    } else if (state.uiState.suggestMode === "agenda-edit-method") {
      if (data.method === "time") {
        state.uiState.suggestMode = "agenda-time-select";
        rerender();
      } else {
        state.uiState.suggestMode = "agenda-edit-duration";
        ui.textBox.value = "";
        ui.textBox.placeholder = "min";
        rerender();
      }
    } else if (state.uiState.suggestMode === "agenda-start-overlap") {
      if (data.choice === "overlap_cancel") {
        pending.startRequest = null;
        if (state.uiState.historyStack.length > 0) state.uiState.historyStack.pop();
        restoreHistory();
        return;
      }
      if (!pending.startRequest) {
        closeAndClear();
        return;
      }
      const payload = pending.startRequest;
      pending.startRequest = null;
      if (data.choice === "overlap_yes") {
        for (const act of payload.active) {
          await endActivity(state, { activityName: act.name, endTime: payload.startTime, preciseUnix: payload.preciseUnix, targetFile: act.sourceFile, skipRefresh: true });
        }
      }
      await startActivity(state, { activityName: payload.activityName, startTime: payload.startTime, plannedEndTime: payload.plannedEndTime, existingRowId: payload.existingRowId, preciseUnix: payload.preciseUnix, onRefresh: refreshEmbed });
      closeAndClear();
    } else if (state.uiState.suggestMode === "agenda-resume") {
      if (data.choice === "resume_yes") {
        const nowStr = state.now.nowTime();
        const ts = Date.now();
        for (const act of pending.resumable || []) {
          await startActivity(state, { activityName: act.name, startTime: nowStr, plannedEndTime: act.endTime, existingRowId: null, preciseUnix: ts, onRefresh: refreshEmbed });
        }
      }
      closeAndClear();
    } else if (state.uiState.suggestMode === "agenda-delete-confirm") {
      if (data.choice === "delete_yes") {
        await deleteActivity(state, { rowId: pending.existingId, activityName: pending.activity, targetFile: pending.targetFile, onRefresh: refreshEmbed });
        closeAndClear();
      } else {
        closeAndClear();
      }
    } else if (state.uiState.suggestMode === "agenda-time-select") {
      if (data.custom) {
        state.uiState.suggestMode = "agenda-time-hour";
        ui.textBox.value = "";
        ui.textBox.placeholder = "HH";
        rerender();
      } else {
        const preciseTs = data.precise ? Date.now() : null;
        await handleTimeSelection(data.time || state.now.nowTime(), preciseTs);
      }
    } else if (state.uiState.suggestMode === "agenda-plan-method") {
      if (data.method === "duration") {
        state.uiState.suggestMode = "agenda-plan-duration";
        ui.textBox.value = "";
        ui.textBox.placeholder = "min";
        rerender();
      } else if (data.method === "open") {
        await processStartRequest({ activityName: pending.activity, startTime: pending.startTime, plannedEndTime: null, existingRowId: pending.existingId, preciseUnix: pending.preciseTimestamp });
      } else {
        state.uiState.suggestMode = "agenda-time-hour";
        pending.action = "plan-end-manual";
        ui.textBox.value = "";
        ui.textBox.placeholder = "HH";
        rerender();
      }
    }
    const items = listEl.querySelectorAll(".suggest-item");
    if (items.length > 0) setActive(0);
  }

  async function handleTimeSelection(timeStr, preciseTs = null) {
    const pending = getPending();
    if (pending.action === "end") {
      const startUnix = await endActivity(state, { activityName: pending.activity, endTime: timeStr, preciseUnix: preciseTs, targetFile: pending.targetFile, onRefresh: refreshEmbed });
      const exclude = pending.activity === "Break" ? ["Break"] : ["Break", pending.activity];
      const candidates = await queries.getInterruptedActivitiesByUnix(startUnix, exclude);
      if (candidates.length > 0) {
        pending.resumable = candidates;
        state.uiState.suggestMode = "agenda-resume";
        panel.style.display = "block";
        state.uiState.panelOpen = true;
        reposition();
        await rerender();
        setTimeout(() => ui.textBox.focus(), 0);
        return;
      }
      closeAndClear();
      return;
    }
    if (pending.action === "edit") {
      await editActivity(state, { rowId: pending.existingId, field: pending.editField, newVal: timeStr, preciseUnix: preciseTs, targetFile: pending.targetFile, onRefresh: refreshEmbed });
      pending.lastEditedTime = timeStr;
      state.uiState.suggestMode = "agenda-edit-chain";
      ui.textBox.value = "";
      await rerender();
      return;
    }
    if (pending.action === "plan-end-manual") {
      await processStartRequest({ activityName: pending.activity, startTime: pending.startTime, plannedEndTime: timeStr, existingRowId: pending.existingId, preciseUnix: pending.preciseTimestamp });
      return;
    }
    pending.startTime = timeStr;
    pending.preciseTimestamp = preciseTs;
    state.uiState.suggestMode = "agenda-plan-method";
    ui.textBox.value = "";
    await rerender();
  }

  function handleDurationInput(minutes) {
    const pending = getPending();
    if (pending.action === "edit") {
      const baseMins = state.time.timeToMins(pending.lastEditedTime);
      const newMins = pending.editField === "end" ? baseMins + minutes : baseMins - minutes;
      editActivity(state, { rowId: pending.existingId, field: pending.editField, newVal: state.time.minsToTime(newMins), targetFile: pending.targetFile, onRefresh: refreshEmbed });
      closeAndClear();
    }
  }

  async function maybePromptResumeFromUnix(interruptUnix, excludeNames = []) {
    const candidates = await queries.getInterruptedActivitiesByUnix(interruptUnix, excludeNames);
    if (candidates.length === 0) return false;
    const activeNowObjs = await queries.getActiveActivities();
    const activeNowNames = activeNowObjs.map((a) => a.name);
    getPending().resumable = candidates.filter((c) => !activeNowNames.includes(c.name));
    if (getPending().resumable.length === 0) return false;
    state.uiState.suggestMode = "agenda-resume";
    panel.style.display = "block";
    state.uiState.panelOpen = true;
    reposition();
    await rerender();
    setTimeout(() => ui.textBox.focus(), 0);
    return true;
  }

  function findDotCommaAnchor() {
    const s = ui.textBox.value;
    const cursor = ui.textBox.selectionStart ?? s.length;
    for (let i = cursor - 1; i >= 1; i -= 1) {
      const ch = s[i];
      if (ch === " " || ch === "\n" || ch === "\t") break;
      if (ch === "," && s[i - 1] === ".") return i - 1;
    }
    return null;
  }

  function handleInput() {
    if (findDotCommaAnchor() !== null) {
      state.uiState.suggestMode = "agenda-keysentences";
      state.uiState.panelOpen = true;
      panel.style.display = "block";
      reposition();
      rerender();
      return;
    }
    if (state.uiState.panelOpen && state.uiState.suggestMode === "agenda-keysentences") closePanel();
    if (state.uiState.panelOpen) rerender();
  }

  function handleKeydown(e) {
    const pending = getPending();
    if (e.key === "<" && ui.textBox.value.trim() === "") {
      setTimeout(() => {
        state.uiState.suggestMode = "agenda-root";
        panel.style.display = "block";
        state.uiState.panelOpen = true;
        reposition();
        rerender();
      }, 10);
      return;
    }
    if (e.key === "Escape") {
      if (state.uiState.panelOpen) {
        closePanel();
        e.preventDefault();
      } else if (ui.textBox.value.trim() === "") {
        state.uiState.suggestMode = "agenda-consumption-select";
        panel.style.display = "block";
        state.uiState.panelOpen = true;
        reposition();
        rerender();
      }
      return;
    }
    if (!state.uiState.panelOpen) {
      if (e.key === "Enter") {
        e.preventDefault();
        ui.onSend?.();
      }
      return;
    }

    if (e.key === "ArrowLeft") {
      e.preventDefault();
      restoreHistory();
      return;
    }
    if (e.key === "ArrowRight") {
      e.preventDefault();
      triggerForward();
      return;
    }

    if (state.uiState.suggestMode === "agenda-time-hour" && e.key === "Enter") {
      e.preventDefault();
      const raw = ui.textBox.value.trim();
      if (/^\\d{1,2}$/.test(raw) && Number(raw) >= 0 && Number(raw) <= 23) {
        pending.partialTime = pending.partialTime || {};
        pending.partialTime.h = Number(raw);
        state.uiState.suggestMode = "agenda-time-minute";
        ui.textBox.value = "";
        ui.textBox.placeholder = "MM";
        rerender();
      }
      return;
    }
    if (state.uiState.suggestMode === "agenda-time-minute" && e.key === "Enter") {
      e.preventDefault();
      const raw = ui.textBox.value.trim();
      if (/^\\d{1,2}$/.test(raw) && Number(raw) >= 0 && Number(raw) <= 59) {
        handleTimeSelection(`${String(pending.partialTime.h).padStart(2, "0")}:${String(raw).padStart(2, "0")}`);
      }
      return;
    }
    if (state.uiState.suggestMode === "agenda-plan-duration" && e.key === "Enter") {
      e.preventDefault();
      const raw = ui.textBox.value.trim();
      if (/^\\d+$/.test(raw) && Number(raw) > 0) {
        const endMins = state.time.timeToMins(getPending().startTime) + Number(raw);
        processStartRequest({ activityName: getPending().activity, startTime: getPending().startTime, plannedEndTime: state.time.minsToTime(endMins), existingRowId: getPending().existingId, preciseUnix: getPending().preciseTimestamp });
      }
      return;
    }
    if (state.uiState.suggestMode === "agenda-edit-duration" && e.key === "Enter") {
      e.preventDefault();
      const raw = ui.textBox.value.trim();
      if (/^\\d+$/.test(raw) && Number(raw) > 0) handleDurationInput(Number(raw));
      return;
    }
    if (state.uiState.suggestMode === "agenda-rename-input" && e.key === "Enter") {
      e.preventDefault();
      const raw = ui.textBox.value.trim();
      if (raw) {
        editActivity(state, { rowId: getPending().existingId, field: "name", newVal: raw, targetFile: getPending().targetFile, onRefresh: refreshEmbed });
        closeAndClear();
      }
      return;
    }

    if (state.uiState.suggestMode === "agenda-consumption-amount" && e.key === "Enter") {
      e.preventDefault();
      const raw = ui.textBox.value.trim();
      recordConsumption(state, { item: getPending().consumptionItem, amount: raw === "" ? "1" : raw }).then(() => closeAndClear());
      return;
    }
    if (state.uiState.suggestMode === "agenda-consumption-double-1" && e.key === "Enter") {
      e.preventDefault();
      getPending().tempStorage.val1 = ui.textBox.value.trim() || "1";
      state.uiState.suggestMode = "agenda-consumption-double-2";
      ui.textBox.value = "";
      rerender();
      return;
    }
    if (state.uiState.suggestMode === "agenda-consumption-double-2" && e.key === "Enter") {
      e.preventDefault();
      const val2 = ui.textBox.value.trim() || "-";
      recordConsumption(state, { item: getPending().consumptionItem, amount: `${getPending().tempStorage.val1} (${val2})` }).then(() => closeAndClear());
      return;
    }

    if (["agenda-time-hour", "agenda-time-minute", "agenda-plan-duration", "agenda-edit-duration"].includes(state.uiState.suggestMode)) {
      if (e.key.length === 1 && !/\\d/.test(e.key) && !e.ctrlKey && !e.metaKey) e.preventDefault();
      return;
    }

    const items = listEl.querySelectorAll(".suggest-item");
    if (e.key === "ArrowDown") {
      e.preventDefault();
      setActive(Math.min(state.uiState.activeIndex + 1, items.length - 1));
    } else if (e.key === "ArrowUp") {
      e.preventDefault();
      setActive(Math.max(state.uiState.activeIndex - 1, 0));
    } else if (e.key === "Enter") {
      e.preventDefault();
      const selected = items[state.uiState.activeIndex];
      if (selected) {
        const data = {
          code: selected.dataset.code,
          value: selected.dataset.value,
          time: selected.dataset.time,
          custom: selected.dataset.custom === "true",
          method: selected.dataset.method,
          id: selected.dataset.id,
          precise: selected.dataset.precise === "true",
          field: selected.dataset.field,
          choice: selected.dataset.choice,
          start: selected.dataset.start,
          end: selected.dataset.end,
          file: selected.dataset.file,
        };
        selectItem(data);
      }
    }
  }

  function openAgendaRoot() {
    state.uiState.suggestMode = "agenda-root";
    panel.style.display = "block";
    state.uiState.panelOpen = true;
    reposition();
    rerender();
  }

  function openConsumption() {
    state.uiState.suggestMode = "agenda-consumption-select";
    panel.style.display = "block";
    state.uiState.panelOpen = true;
    reposition();
    rerender();
  }

  function destroy() {
    try {
      ui.panelHost.removeChild(panel);
    } catch (e) {
      /* ignore */
    }
  }

  return {
    panel,
    rerender,
    closePanel,
    reposition,
    handleInput,
    handleKeydown,
    openAgendaRoot,
    openConsumption,
    maybePromptResumeFromUnix,
    destroy,
  };
}

module.exports = { createSuggester };

});
__define('ui/ui_shared/baseStyles.js', function(module, exports, require) {
/**
 * Base styles applied to the planner UI and suggester panel.
 */
const baseCss = `
.chat-wrap{font:14px/1.45 var(--font-interface);background:#54B5FB !important; border:1px solid var(--background-modifier-border); border-radius:12px; padding:12px; display:flex; flex-direction:column; gap:8px}
.row{display:flex; gap:6px; flex-wrap:wrap; align-items:center}
textarea{width:100%; height:88px; resize:vertical; border-radius:10px; padding:10px; border:1px solid var(--background-modifier-border);background:#094782 !important; color:var(--text-normal)}
textarea.ref{width:50%; min-height:10px}
textarea.ref2{width:48%; min-height:10px;background:var(--background-primary);border-color:var(--background-primary);cursor:none}
.log{max-height:260px; overflow:auto; padding:6px; background:var(--background-secondary); border-radius:8px}
.msg{margin:6px 0}
.msg .meta{font-size:12px; color:var(--text-muted)}
.embed-box { display:none; }

.suggest-panel{position:absolute; z-index:9999; max-height:280px; overflow:auto; border:1px solid var(--background-modifier-border); background:var(--background-primary); border-radius:8px; padding:6px; box-shadow:0 8px 24px rgba(0,0,0,.25); min-width:320px}
.suggest-head{display:flex; gap:8px; align-items:center; padding:4px 6px 8px 6px; border-bottom:1px solid var(--background-modifier-border); justify-content: space-between;}
.suggest-bc{font-size:12px; color:var(--text-muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; flex-grow: 1;}
.suggest-nav{display:flex; gap:4px;}
.nav-btn{padding:2px 10px; border-radius:4px; border:1px solid var(--background-modifier-border); background:var(--interactive-normal); cursor:pointer; font-size:14px; line-height:1;}
.suggest-list{margin-top:6px}
.suggest-item{padding:6px 8px; border-radius:6px; cursor:pointer; display:flex; gap:8px; align-items:center}
.suggest-item:hover,.suggest-item.active{background:var(--background-secondary)}
.suggest-item small{opacity:.7}
.suggest-icon{width:1.2em; text-align:center}
.suggest-item.active{outline:1px solid var(--interactive-accent)}
.suggest-input-hint{padding:8px; font-style:italic; opacity:0.8; border-top:1px solid var(--background-modifier-border)}
.suggest-section-title{margin:6px 0 2px 0; font-size:11px; color:var(--text-muted); text-transform:uppercase; letter-spacing:0.05em; font-weight:600;}
/* Calendar */
.cal-box{display:none; position:fixed; z-index:10050; width:320px; max-width:92vw; background:var(--background-primary); border:1px solid var(--background-modifier-border); border-radius:12px; box-shadow:0 12px 40px rgba(0,0,0,.35); padding:10px}
.cal-head{display:flex; align-items:center; justify-content:space-between; gap:6px; padding:4px 2px 10px 2px}
.cal-title{font-weight:700; font-size:13px; text-align:center; flex:1}
.cal-nav{display:flex; gap:4px}
.cal-nav button{padding:2px 8px; border-radius:6px; border:1px solid var(--background-modifier-border); background:var(--interactive-normal); cursor:pointer}
.cal-week{display:grid; grid-template-columns:repeat(7,1fr); gap:4px; margin-bottom:6px; font-size:11px; color:var(--text-muted); text-align:center}
.cal-grid{display:grid; grid-template-columns:repeat(7,1fr); gap:4px}
.cal-day{border-radius:6px; padding:8px 0; text-align:center; cursor:pointer}
.cal-day:hover{background:var(--background-secondary)}
.cal-day.today{outline:1px solid var(--interactive-accent)}
.cal-day.selected{background:var(--interactive-accent); color:var(--text-on-accent);}
.cal-day.muted{opacity:0.5}
`;

module.exports = { baseCss };

});
return __requireModule('index.js');
})();
```
